___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 114 蓝图中判断Tag读取广播的结构体设置UI；客户端无法触发添加技能的回调，需要重写父类属性复制回调函数，初始化时广播

___________________________________________________________________________________________

## 处理关键点

1. GAS的核心设计是以网络安全性为优先的。只有 `服务器`  `可以` 直接 `授予` 或 `修改`  `GA`能力 !!!!!!!!!!!!

2. `客户端` 如果想在 `GiveAbility` 的时候 `绑定回调` 需要 `重写` 父类 虚函数 `OnRep ActivateAbilities`


___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[8. Binding Widget Events to the Ability Info Delegate_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=40&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

```mermaid
graph TD
    A[开始：配置技能UI]
    
    B[设置变量绑定代理]
    A --> B
    B --> B1[广播给每个技能UI]

    C[识别保存自身数据的结构体]
    B --> C
    C --> C1[配置每个UI的Tag]

    D[创建InputTag变量]
    C1 --> D

    E[创建函数：配置技能图标的输入按键]
    D --> E
    E1[函数命名：SetSpellGlobeInputTags]
    E --> E1

    F[初始化时调用函数]
    E1 --> F

    G[技能UI使用MachesTag检查Tag匹配]
    F --> G
    G1[如果匹配，调用设置技能图标的函数]
    G --> G1

    H[折叠为函数：ReceiveAbilityInfo]
    G1 --> H

    I[运行测试：技能图标缺失]
    H --> I

    J[修复：给技能添加AbilityTag]
    I --> J
    J1[测试仍然没有技能图标]
    J --> J1

    K[断点调试：技能UI未设置WidgetController]
    J1 --> K

    L[创建函数：设置技能UI的WidgetController]
    K --> L
    L1[函数命名：SetGlobeWidgetControllers]
    L --> L1
    L2[运行成功，显示技能图标]
    L1 --> L2

    M[多人LS模式客户端无法显示技能图标]
    L2 --> M
    M1[问题原因：逻辑只在服务器上执行]
    M --> M1
    M2[解决方案：在客户端广播]
    M1 --> M2

    N[网络安全设计：只有服务器可修改能力]
    M2 --> N

    O[重写虚函数：OnRep_ActivateAbilities]
    N --> O
    O1[初始化时广播数据]
    O --> O1

    P[判断状态：首次广播后设置为false]
    O1 --> P

    Q[客户端运行测试：显示技能图标]
    P --> Q

    R[动态配置：修改GA的InputTag触发UI变化]
    Q --> R

```



___________________________________________________________________________________________

### 接下来需要在蓝图中配置结构体和UI
>![这里是图片](./Image/GAS_114/1.png)


------

### `技能UI` 触发蓝图中的 `WidgetControllerSet` 函数后，设置变量绑定代理

> #### **现在有几个技能就会广播给每个 `技能UI` 几次**
>
> ![这里是图片](./Image/GAS_114/2.png)


------

### 接下来需要让 `技能UI` 识别保存自身数据的结构体，所以需要为每一个UI配置Tag


------

####  `技能UI` 上创建 `InputTag` 变量
>![这里是图片](./Image/GAS_114/3.png)


------

#### 在之前创建的配置技能图标的UI中可以知道每个 `技能UI` 对应着什么输入按键，所以需要在这里创建函数配置
>![这里是图片](./Image/GAS_114/4.png)
>
>### 依次改名![这里是图片](./Image/GAS_114/5.png)


------

##### 创建函数配置，命名为，`SetSpellGlobeInputTags`
>![这里是图片](./Image/GAS_114/6.png)


------

#### 初始化时调用
>![这里是图片](./Image/GAS_114/7.png)


------

####  `技能UI` 中使用API：MachesTag检查两个Tag是否匹配
>![这里是图片](./Image/GAS_114/8.png)


------

##### 如果匹配，调用之前创建的设置技能图标的函数
>![这里是图片](./Image/GAS_114/9.png)


------

##### 将这一大段逻辑折叠为函数命名为，`ReceiveAbilityInfo`
>![这里是图片](./Image/GAS_114/10.png)![这里是图片](./Image/GAS_114/11.png)


------

### 运行测试发现我们还没有技能图标

>#### **因为技能中没有配置技能 `AbilityTag`**![这里是图片](./Image/GAS_114/12.png)![这里是图片](./Image/GAS_114/13.png)


------

### 修复问题，给技能添加 `AbilityTag`
>![这里是图片](./Image/GAS_114/14.png)


------

### 运行发现还是没有技能图标


------

### 断点调试
>![这里是图片](./Image/GAS_114/15.png)


------

#### 我们好像没有设置 `技能UI` 的 `WidgetController` ，所以不会触发 `WidgetControllerSet` 函数


------

### 创建函数设置 `技能UI` 的 `WidgetController`，命名为 `SetGlobeWidgetControllers` ，父层，调用设置 `WidgetController`
>![这里是图片](./Image/GAS_114/16.png)


------

### 此时运行，就可以看到技能图标了
>![这里是图片](./Image/GAS_114/17.png)


------

### 还有一个问题，多人LS模式下，客户端无法显示技能图标

> #### **因为这里的逻辑只在服务器上执行**![这里是图片](./Image/GAS_114/19.png)![这里是图片](./Image/GAS_114/18.png)
>
>   - 因此，我们也需要一种在客启端上广播它的方法，并且有一个很好的简单方法可以做到这一点，一旦我们给出了我们的能力，那么能力系统组件可激活的能力容器就会将其复制为一个复制变量


------

## GAS的核心设计是以网络安全性为优先的。`只有服务器端代码可以直接授予或修改能力!!!!!!!!!!!!`

## 这是为了防止客户端直接操纵能力，例如通过修改客户端代码进行作弊。


------

### 可以搜索源码 `GetActivatablAbilities`

>   - 可以看到这是一个虚函数，可以子类重写![这里是图片](./Image/GAS_114/20.png)![这里是图片](./Image/GAS_114/21.png)![这里是图片](./Image/GAS_114/22.png)![这里是图片](./Image/GAS_114/23.png)
>


------

### 重写虚函数 `OnRep ActivateAbilities`
>```CPP
>protected:
>
>    virtual void OnRep_ActivateAbilities() override;
>    
>```
>
>![这里是图片](./Image/GAS_114/24.png)
>
>#### **这样带来的后果就是每次复制都会广播数据，但我们只想在第一复制的时候也就是初始化时广播**
>
>![这里是图片](./Image/GAS_114/25.png)


------

### 需要判断状态，限定一下，只有当没有被广播时，才可以广播，并在广播后设置 bool = false

> #### **因为这里的逻辑，在客户端。而且因为客户端不会走之前的逻辑，而是走这里的逻辑，且第一次走到这里时肯定为false，所以会按照设计执行初始化**
>
> ```cpp
> void UAuraAbilitySystemComponent::OnRep_ActivateAbilities()
> {
>     Super::OnRep_ActivateAbilities();
> 
>     if (!bStartupAbilitiesGiven)
>     {
>        bStartupAbilitiesGiven = true;
>        AbilitiesGiven.Broadcast(this);
>     }
> }
> ```
>
> ![这里是图片](./Image/GAS_114/26.png)


------

### 运行测试客户端也可以看到技能图标
>![这里是图片](./Image/GAS_114/27.png)


------

### 因为我们是 `动态配置` 的，所以修改 `GA` 的 `InputTag` ，也会触发UI上的变化


------

#### 改一下试试
>![这里是图片](./Image/GAS_114/29.png)![这里是图片](./Image/GAS_114/30.png)
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
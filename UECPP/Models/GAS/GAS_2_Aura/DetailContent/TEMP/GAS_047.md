___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 047 

___________________________________________________________________________________________

> ## 处理关键点
>
> 1. A类中绑定和广播B类中的动态多播(这里A类和B类是举例说明，非特指)
> 2. 回顾 **`UObject`** 类都有哪些 **`功能`** 和 **`子类`** ？
> 3. 当属性值发生变化触发的多播委托如何获取？
> 4. **使用变量常会涉及到的问题：**
>    1. 何时初始化？
>    2. 何时绑定委托？
>    3. 何时广播？
>    4. 何时广播初始值？

___________________________________________________________________________________________

# 目录


[TOC]

___________________________________________________________________________________________

### 欢迎来到你的下一个任务。现在，我们将创建一个敌人生命值条

#### 希望给敌人创建血条UI,然后当属性变化时多播发送至UI中更新数据

![image-20240805233026667](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805233026667.png)

![image-20240805233119051](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805233119051.png)

1. 
在敌人 持有自身的UI指针

![image-20240805234209315](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805234209315.png)

构造中创建UI组件`WidgetComponent`并绑定到根组件

![image-20240805234354461](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805234354461.png)

_________________

在这个路径下创建敌人血条UI

![image-20240805234631333](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805234631333.png)

继承自`AuraUserWidget`

![image-20240805234715829](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805234715829.png)

叫 *WBP_ProgressBar*
1. 创建`SizeBox`设置为变量,改名为`SizeBox_Root
2. 在蓝图中创建配置的函数
3. Width和Height分别创建变量 `BoxWidth` `BoxHeight`，创建分组ProgressBarProperties
4. 设置形状`80*6`
5. 合并为函数取名`UpdateBoxSize`

![image-20240805235324368](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240805235324368.png)

1. 创建`Overlay`设置为变量，改名`Overlay_Root`
2. 创建`ProgressBar`设置为变量，改名**`ProgressBar_Front`**并将`Style->BackgroundImage->Tint->Alpha`设置为0（这样就有了透明背景）如果想调节颜色只需要调节`Style->FillImage->Tint`的颜色即可
3. 蓝图中设置**`ProgressBar_Front`**的`Style`把`FillImage`设置为参数取名`FrontBarFillBrush`放入之前的组ProgressBarProperties中
4. 设置`FrontBarFillBrush`默认值为红色(血条颜色)
5. 合并为函数，取名`UpdateFrontFillBrush`

![image-20240806000058363](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806000058363.png)

![image-20240806000510045](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806000510045.png)

_______

### 配置敌人血条的组件

1. 设置敌人血条的组件为屏幕空间显示
2. 配置刚创建的UI *WBP_ProgressBar*
3. 勾选绘制UI的尺寸

![image-20240806000723024](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806000723024.png)

![image-20240806000933616](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806000933616.png)

![image-20240806000915850](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806000915850.png)

此时点击运行，发现敌人的血条有点居中，需要向上加一点偏移

![image-20240806001041504](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806001041504.png)

![image-20240806001058580](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806001058580.png)

![image-20240806001334628](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806001334628.png)

________

但是此时向敌人射击并不会影响到UI

![image-20240806001153558](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806001153558.png)

此时需要为敌人血条UI设置数据

_____________

#### 思考一下:哪个类将拥有代理来广播，以便我们可以将其绑定到我们的进度条上?

> 此前已经在 `OverlayWidgetController` 中创建了动态广播，**可以通过引用该类的头文件，使用该广播**
>
> ![image-20240806001839511](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806001839511.png)

使用该委托，引入 `OverlayWidgetController` 的头文件

![image-20240806002118939](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806002118939.png)

![image-20240806002414923](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806002414923.png)

### 头文件中引入头文件需要注意不要循环引用的问题!

> **所以不需要创建新的委托。我们实际上可以重复使用一个已经存在的委托来实现这个目的**

#### 思考一下:我们什么时候将这些广播到我们的健康条上?

> 思路：
>
> 1. 当属性变化时，变化的值将会被广播，我们可以绑定这些
> 2. 需要在绑定这些前，将`ASC组件`初始化，在敌人类中这发生在重写的 `BeginPlay` 函数中![image-20240806003000990](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806003000990.png)
> 3. 想要在 `BeginPlay` 函数中，初始化完成后，绑定属性变化通知广播![image-20240806003124418](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806003124418.png)
> 4. 需要获取自建的 `UAuraAttributeSet` 对象，所以先获取 `UAuraAttributeSet` 对象(身上有，`Cast` 一下就行)
> 5. 获取委托后想要绑定一个回调函数，此时决定使用 `Lambda表达式` ，这样避免过多的函数(类型需要为： `const FOnAttributeChangeData& Data` )![image-20240806003620844](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806003620844.png)

这里需要代码

```CPP

//先放个临时的图片
```

![先放个临时的](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806003857002.png)

___________________________________________________________________________________________

```CPP
//MaxHealth也需要找这样处理
//先放个临时的图片
```

![image-20240806004018194](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806004018194.png)

处理一下更简洁

![image-20240806004136028](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806004136028.png)

> **所以现在，当健康和最大健康值发生变化时，会被广播**

#### 剩下的就是，将属性变化的多播委托，绑定到我们的进度条UI *WBP_ProgressBar* 上

> 此时需要创建 *WBP_ProgressBar* 的子类，想要创建一个专门处理血条用的子类，**防止逻辑耦合**
>
> 1. 创建子类继承自 *WBP_ProgressBar* ，取名为 *WBP_EnemyHealthBar* (处理敌人血条绑定的类)
> 2. 敌人血条组件更换血条UI引用为子类![image-20240806004810766](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806004810766.png)

### 梳理一下目前的操作

> 1. 在敌人 `AAuraEnemy` 身上绑定了，属性变化通知(动态多播)
> 2. 敌人 `AAuraEnemy` 身上创建了动态多播 `OnHealthChanged` 和 `OnMaxHealthChanged` ，上面属性变化通知时，把结果通过 `OnHealthChanged` 和 `OnMaxHealthChanged` 广播
> 3. 此时**还没有**在 UI 中进行绑定，但是绑定多播委托需要一个 **`WidgetController` **对象
>
> 问题来了：如何获取 **`WidgetController` **对象并把多播 `OnHealthChanged` 和 `OnMaxHealthChanged` 绑定到 UI ?

![](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/UECPP/Models/GAS/GAS_2_Aura/DetailContent/Image/ThinkAbout.png?raw=true)

> 1. 打算加在这里，在绑定回调并开始广播之前![image-20240806010322012](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806010322012.png)
> 2. 使用API:拿到UI对象
>     ![image-20240806011720382](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806011720382.png)
> 3. 可将自身设置为 `WidgetController` ![image-20240806011836217](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806011836217.png)
>
> 太完美了！

**此时状态为：在设置 `WidgetController` 之后，再将lambda函数绑定到回调函数**

- 但是，第一次逻辑走到这里时，当设置了 `WidgetController` ，然后绑定了两个 `Lambda` 回调，此时状态并没有发生变化

- 也就是逻辑走完两个 `Lambda` 之后，并没有广播初始值，所以需要添加一个广播初始值的逻辑

**下面加上广播初始值的逻辑：**

```CPP
//这里加上广播初始值的逻辑

```



![image-20240806012751947](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806012751947.png)

_____________________________________

重新编译一下

______________________

**因为当 `AuraWidgetController` 中的逻辑：当 `SetWidgetController` 被调用后，会触发 `WidgetControllerSet` (蓝图实现的函数)**

- 所以此时UI中可以使用![image-20240806012946810](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806012946810.png)
- 当这个函数触发时，说明 **绑定** 和 **初始化**已结束，可以安心绑定回调 `OnHealthChanged` 和 `OnMaxHealthChanged` 
- 创建两个 `float` 变量 `Health` 和 `MaxHealth` 保存 广播收到的变量
- 并在每次设置 `Health` 和 `MaxHealth` 之后添加计算当前血量百分比的逻辑![image-20240806013619346](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806013619346.png)

### 此时结果gif

![image-20240806013716907](C:\Users\ROG\AppData\Roaming\Typora\typora-user-images\image-20240806013716907.png)


___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
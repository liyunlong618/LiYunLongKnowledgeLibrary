

+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 062 使用ExecutionCalculations计算伤害

___________________________________________________________________________________________

## 处理关键点

1. 111111111111111111111111111111

2. 222222222222222222222222222

3. 33333333333333333333333333

4. 4444444444444444444444444444

5. 555555555555555555555555555555

6. 666666666666666666666666666

7. 77777777777777777777777777777777

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[12. Damage Execution Calculation_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=141&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

[13. ExecCalcs - Capturing Attributes_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=142&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

</details>

___________________________________________________________________________________________

### 整体思路梳理

Mermaid



___________________________________________________________________________________________

> 当我们需要计算受到的伤害时(比如计算护甲/魔抗之类)就要用到 **`自定义计算方式`** 
>
> 我们需要使用 `GE->Modifiers->ModifierMagnitude->MagnitudeCalculationType` 下的 `Custom Calculation Class`![](./GAS_062/1.PNG)

------

### 创建自定义计算的C++类

1. `C++类/Aura/Public/AbilitySystem/` 文件夹下，新建文件夹，命名为 `ExecCalc`

2. 创建 `GameplayEffectExecutionCalculation` 类，命名为 `ExecCalc_Damage`

> 这是我们 **`基于游戏效果执行计算的自定义计算类`**，类似于MMC(自定义伤害计算类)

- 需要创建一个构造函数

  ```CPP
  UExecCalc_Damage();
  ```

- 需要重写一个虚函数 `Execute_Implementation`，有两个参数

<details>
<summary>介绍虚函数 Execute_Implementation</summary>

> | 参数            | 用途                                            |
> | --------------- | ----------------------------------------------- |
> | fffffffffffffff | 传入的参数，可以获取很多数据                    |
> | fffffffffffff   | 没有const，说明是传入参数，通过引用改变参数输出 |
>
>   函数内部可以不调用 `Super` !
>
>   可以通过 `ExecutionParams.` 获取好多有用的参数，比如：
>
> | 参数                                            | 获取的数据               |
> | ----------------------------------------------- | ------------------------ |
> | ExecutionParams.GetOwningSpec                   | 拥有此计算的游戏效果规范 |
> | ExecutionParams.GetPredictionKey                | 获取预测密钥             |
> | ExecutionParams.GetSourceAbilitySystemComponent | 获取Source的ASC组件      |
> | ExecutionParams.GetTargetAbilitySystemComponent | 获取Target的ASC组件      |
> | ...                                             | ...                      |
>
>   ![](./GAS_062/2.PNG)

------

</details>
虚函数 `Execute_Implementation` 中需要从 `ExecutionParams` 获取

1. **SourceAbilitySystemComponent**，命名为 `SourceASC` 
2. **TargetAbilitySystemComponent**，命名为 `TargetASC` 
3. **SourceActor**，命名为 `SourceAvatar` 
4. **TargetActor**，命名为 `TargetAvatar` 
5. **GameplayEffectSpec**，命名为 `Spec` 

![](./GAS_062/2.PNG)

```CPP
上代码
```

------

> 以上为创建 `GameplayEffectExecutionCalculation` 类，并获取数据的步骤，下面将**捕获属性**并计算

------

**在虚幻官方演示的动作RPG项目中，多次使用这样的方式：**

那就是，**创建一个结构体来储存我们捕获的属性定义**，并对其进行定义

<details>
<summary>回顾之前的MMC(UModifierMagnitudeCalculation)中的捕获属性的方式</summary>


> 这些属性捕获定义是我们捕获属性的方式。
> 1. 首先我们使用构造函数来设置捕获参数定义并将其添加到相关属性中以捕获。这就是我们在MMC中捕获属性的方式。
>    - MMC类本身上的属性捕获定义的T数组 `RelevantAttributesToCapture`
> 2. 使用了一个捕获定义，并在实际函数 `CalculateBaseMagnitude_Implementation` 中计算
>    - 我们创建了一些评估参数，并在函数GetCapturedAttributeMagnitude中，传递评估参数引用，然后得到了捕获属性的值。
> 3. 这就是 MMC 中捕获属性的方式。
>
> ![](./GAS_062/5.PNG)![](./GAS_062/6.PNG)

------


</details>

> **在 ExecutionCalculations 中我们也将使用这种捕获属性的方式，但是，这次使用官方给的帮助宏和结构体，除了计算方式与MMC略有不同**

---
### 捕获属性 第一步：创建一个结构体

命名为 `AuraDamageStatics`
- 没有使用 `F` 开头因为，这是一个原始结构
  - **完全不会将其暴露给蓝图或反射系统**
  - **也不是一个 `U` 类结构**，所以不用添加那个对于 `U` 结构所需的 `F`
  - **也不需要 `GENERATE_BODY` 宏**
- **这只是一个在这个CPP文件中使用的原始内部结构**

```CPP
struct 
```

---
### 捕获属性 第二步：为结构体创建构造

```CPP
构造
```

---
### 捕获属性 第三步：在全局域中创建一个静态的结构体对象实例并返回

> 静态对象意味着，第一次访问时将创建一个实例，并返回。后续每次访问，只返回该实例。

```CPP
全局域中创建一个静态的结构体对象实例并返回
```

![](./GAS_062/7.PNG)

---
### 捕获属性 第四步：使用官方帮助处理的宏 帮助 声明一些新的捕获定义

- **官方 `帮助声明新的捕获定义` 的 宏**

  ```CPP
  DECLARE_ATTRIBUTE_CAPTUREDEF(这里填入要捕获的AS中的属性名);
  ```

- 使用这个宏来为我们创建一个 **AS属性** `FProperty*` 和一个**捕获定义**的 `FGameplayEffectAttributeCaptureDefinition` 类型变量。

<details>
<summary>使用官方帮助处理的宏 源码</summary>


>`DECLARE_ATTRIBUTE_CAPTUREDEF` 宏
>
>- 接受我放进去的文本，在这种情况下是盔甲
>
>- 创建一个名为 Armor Property 的类型为F属性指针的新变量
>
>- 不一定非要填入 `要捕获的AS中的属性名` 可以是 **`为该属性创建的变量名`**
>
>- 因为传入的内容并不是视为变量，而是视为一个名字
>
>- 所以生成的变量名字为 —— `填入的内容+Def`[^1]
>
>- 比如这里，正在创建一个名为 `ArmorDef` 的 `FGameplayEffectAttributeCaptureDefinition` 类型变量。
>
>下面还有一个
>
>`DEFINE_ATTRIBUTE_CAPTUREDEF` 宏
>
>- 它接受四种不同的东西，分别为 `S` `P` `T` `B`
>
>  | `DEFINE_ATTRIBUTE_CAPTUREDEF` 宏 参数 | 宏中对应的代码片段                                           | 作用                                                  |
>  | :-----------------------------------: | :----------------------------------------------------------- | :---------------------------------------------------- |
>  |                 **S**                 | `S::StaticClass()`                                           | AS的 `类名`                                           |
>  |                 **P**                 | `P##Property`                                                | 这是个 `AS属性`                                       |
>  |                 **T**                 | `EGameplayEffectAttributeCaptureSource::T`                   | 是个EGameplayEffectAttributeCaptureSource类型的`枚举` |
>  |                 **B**                 | `FGameplayEffectAttributeCaptureDefinition` 类有参构造时传入的参数 | `布尔`                                                |
>
>- 宏 中 `GET_MEMBER_NAME_CHECKED(S,P)`看样子是检查 `S` 这个类中有没有 `P` 这个属性
>
>- `P##Def = FGameplayEffectAttributeCaptureDefinition(P##Property,EGameplavEffectAttributeCaptureSource::T,B);` 这行代码看样子是使用有参构造为变量赋值


------


</details>


___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
[^1]: 比如输入的是Armor那么变量名字就是ArmorDef
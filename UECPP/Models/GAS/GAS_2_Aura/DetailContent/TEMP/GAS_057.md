

+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```


___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS_057_敌人受击反应

___________________________________________________________________________________________

## 处理关键点

1. 111111111111111111111111111111

2. 222222222222222222222222222

3. 33333333333333333333333333

4. 4444444444444444444444444444

5. 555555555555555555555555555555

6. 666666666666666666666666666

7. 77777777777777777777777777777777

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[5. Enemy Hit React_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=134&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

</details>

___________________________________________________________________________________________

### 整体思路梳理

Mermaid

___________________________________________________________________________________________
>- 如果我们已经对敌人造成伤害但没有杀死他们，我们可以激活一个能力
>- 当敌人进入受击状态后
>  - 我们不希望敌人能够移动、攻击或做任何事情。
>  - 给这个敌人添加一个游戏标签，结束状态时移除
___________________________________________________________________________________________
### 小测试1

>**下面你需要完成**：
>1. 创建一个受击效果GE，命名为：*GE_HitReact*
>2. 创建一个Tag标签，命名为：`Effects.HitReact`
>3. 在 *GE_HitReact* 中授予Tag `Effects.HitReact`
>4.  *GE_HitReact* 是一个无限持续时间的游戏效果，这样我们可以在以后的某个时间点将其移除。
>![](./GAS_057/1.png)
___________________________________________________________________________________________

<details>
<summary>自己尝试一下</summary>

> 小测试1步骤：
> 1. `Content/BP/GameplayEffects/AbilitySystem/`下创建GE![](./GAS_057/2.png)
>
> 2. AuraGameplayTags.h中
>
>    ```CPP
>    public:
>    	FGameplayTag Effects_HitReact;
>    ```
>
>    AuraGameplayTags.cpp中`InitializeNativeGameplayTags`函数内
>
>    ```CPP
>    GameplayTags.Effects_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag(
>    		FName("Effects.HitReact"),
>    		FString("Effects.HitReact"));
>    ```
>
> 3. 在 *GE_HitReact* 中授予Tag![](./GAS_057/3.png)

</details>

___________________________________________________________________________________________

### 接下来我们需要监听敌人身上FGameplayTag的更改

如果添加或移除了一个游戏标签。我们可以对此做出响应。

- **`FGameplayTag变化的监听委托`需要使用`ASC组件`**
- 需要在`敌人`身上绑定该委托的`回调函数`

> **使用到的API**：
>
> ```CPP
> AbilitySystemComponent->RegisterGameplayTagEvent(要监听的Tag, 该Tag处于何种状态时才广播);
> ```
>
> 调用这个函数时会返回一个委托的引用 `FOnGameplayEffectTagCountChanged&` ![](./GAS_057/4.png)![](./GAS_057/5.png)参数分别为(要监听的Tag,当前Tag新的标签计数[1^])
>
> 每当我们的标签计数发生变化时，我们将收到新的标签计数。

### 第一步：在敌人`AAuraEnemy`身上创建`FGameplayTag的更改`的回调函数并在`BeginPlay`时绑定

函数命名为`HitReactTagChanged`

形参需要为 `const FGameplayTag` (要监听的Tag) 和 `int32` (当前Tag新的标签计数)

+ `头文件`中：

  ```cpp
  public:
  	void HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount);
  ```


+ `源文件`中：`BeginPlay`时绑定`监听Tag变化的回调`![](./GAS_057/6.png)

  ```cpp
  void AAuraEnemy::BeginPlay()
  {
  	Super::BeginPlay();
  	InitAbilityActorInfo();
  	if (UAuraUserWidget* AuraUserWidget = Cast<UAuraUserWidget>(HealthBar->GetUserWidgetObject()))
  	{
  		AuraUserWidget->SetWidgetController(this);
  	}
  	if (const UAuraAttributeSet* AuraAttributeSet = Cast<UAuraAttributeSet>(AttributeSet))
  	{
  		AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(AuraAttributeSet->GetHealthAttribute()).AddLambda(
  		[this](const FOnAttributeChangeData& Data)
  		{
  			OnHealthChanged.Broadcast(Data.NewValue);
  		});
  		AbilitySystemComponent->GetGameplayAttributeValueChangeDelegate(AuraAttributeSet->GetMaxHealthAttribute()).AddLambda(
  			[this](const FOnAttributeChangeData& Data)
  			{
  				OnMaxHealthChanged.Broadcast(Data.NewValue);
  			});
  		//在这里绑定监听Tag变化的回调
  		AbilitySystemComponent->RegisterGameplayTagEvent(FAuraGameplayTags::Get().Effects_HitReact,EGameplayTagEventType::NewOrRemoved).AddUObject(this,&AAuraEnemy::HitReactTagChanged);
  		
  		OnHealthChanged.Broadcast(AuraAttributeSet->GetHealth());
  		OnMaxHealthChanged.Broadcast(AuraAttributeSet->GetMaxHealth());
  	}
  }
  ```
  
  EGameplayTagEventType有三种类型[2^]：
  
  - | 类型           |      调用时机       |
    | -------------- | :-----------------: |
    | AnyCountChange | 任何标签计数变化时  |
    | NewOrRemoved   | 每次新增或移除Tag时 |
    | Type           |          -          |

___________________________________________________________________________________________

### 第二步：敌人`AAuraEnemy`身上创建是否播放受击动画的bool(方便角色动画蓝图获取状态)

```CPP
public:

	UPROPERTY(BlueprintReadOnly, Category = "Combat")
	bool bHitReacting;
```
___________________________________________________________________________________________

### 第三步：敌人`AAuraEnemy`身上创建最大移动速度(若为播放受击动画状态，最大速度应该为0.f)

设置敌人的最大移动速度，默认为`250.f`

```CPP
public:

	UPROPERTY(BlueprintReadOnly, Category = "Combat")
	float BaseWalkSpeed = 250.f;
```

还需要在`BeginPlay函数中`设置敌人的移动速度为`BaseWalkSpeed`![](./GAS_057/7.png)

```CPP
GetCharacterMovement()->MaxWalkSpeed = BaseWalkSpeed;
```



___________________________________________________________________________________________


### 第四步：回调函数内判断：添加或者移除Tag

- |   状态判断    |    状态     |         要执行的逻辑         |
  | :-----------: | :---------: | :--------------------------: |
  | NewCount > 0  | 添加Tag状态 |      MaxWalkSpeed = 0.f      |
  | NewCount <= 0 | 移除Tag状态 | MaxWalkSpeed = BaseWalkSpeed |


回调函数中处理逻辑

```CPP
void AAuraEnemy::HitReactTagChanged(const FGameplayTag CallbackTag, int32 NewCount)
{
	bHitReacting = NewCount > 0;
	GetCharacterMovement()->MaxWalkSpeed = bHitReacting ? 0.f : BaseWalkSpeed;
}
```

___________________________________________________________________________________________

>这样就处理完了添加Tag时的逻辑，接下来需要处理移除Tag的逻

**接下来需要创建一个GA，来处理移除Tag的逻辑**

___________________________________________________________________________________________

### 小测试2

>**下面你需要完成**：
>1. 创建一个游戏能力GA，命名为：*GA_HitReact*
>2. 该GA内需要应用*GE_HitReact*，
>3. *GA_HitReact*被激活时，需要播放一个受击蒙太奇，并在播放完成后移除该蒙太奇，停止该技能
>     ![](./GAS_057/8.png)
___________________________________________________________________________________________

<details>
<summary>自己尝试一下</summary>

> 小测试2步骤：
> 1. 

</details>

___________________________________________________________________________________________
















[1^]:比如释放技能后，会触发这个回调，此时这个标签计数为1,当移除该Tag后，再次触发回调，此时这个标签计数为0
[2^]:比如，若技能的标签计数为3，当选择AnyCountChange后，每次被技能命中都会触发该回调；当选择NewOrRemoved时，敌人身上若没有该tag，敌人身上第一次拥有或者移除该tag时会触发该回调；第三种我也不太了解

___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
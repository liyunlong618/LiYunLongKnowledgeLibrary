___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 151 重构让火球携带初始化参数后的结构体，并在重叠时，设置结构体中关键参数，最后使用结构体应用GE完成逻辑；使用Rider快捷抽象函数

___________________________________________________________________________________________

## 处理关键点

1. 第一步：创建结构体：包含需要用到的很多参数
2. 第二步：创建函数，根据上下文，配置结构体中的参数
3. 第三步：配置好结构体后，可以保存在对象身上，后续修改结构体数据，然后使用结构体应用效果
4. 使用Rider快捷抽象函数

___________________________________________________________________________________________

# 目录


- [GAS 151 重构让火球携带初始化参数后的结构体，并在重叠时，设置结构体中关键参数，最后使用结构体应用GE完成逻辑；使用Rider快捷抽象函数](#gas-151-重构让火球携带初始化参数后的结构体并在重叠时设置结构体中关键参数最后使用结构体应用ge完成逻辑使用rider快捷抽象函数)
  - [处理关键点](#处理关键点)
- [目录](#目录)
    - [Mermaid整体思路梳理](#mermaid整体思路梳理)
    - [这一节，我们将使用这个 `(使用结构体的)函数` 来应用伤害](#这一节我们将使用这个-使用结构体的函数-来应用伤害)
    - [我们打开生成火球的GA `AuraProjectileSpell`](#我们打开生成火球的ga-auraprojectilespell)
      - [需要重构这里的逻辑，使用刚刚创建的函数 `ApplyDamageEffect`，而且之前的火球携带的 `Spec` 后面也不需要携带了，直接携带上面创建一堆参数的结构体 `FDamageEffectParams` 就行](#需要重构这里的逻辑使用刚刚创建的函数-applydamageeffect而且之前的火球携带的-spec-后面也不需要携带了直接携带上面创建一堆参数的结构体-fdamageeffectparams-就行)
      - [接下来修复报错](#接下来修复报错)
        - [先抽象一下，复用的逻辑](#先抽象一下复用的逻辑)
          - [使用Rider的便捷抽象功能](#使用rider的便捷抽象功能)
        - [使用 `结构体中的数据` 和 重叠时的 `OtherActor` 判断](#使用-结构体中的数据-和-重叠时的-otheractor-判断)
        - [压缩代码量](#压缩代码量)
      - [因为在这里是重叠发生时，可以拿到 `TargetActor`，所以接下来，为结构体配置 `TargetASC` ，然后调用刚刚创建的函数  `ApplyDamageEffect`](#因为在这里是重叠发生时可以拿到-targetactor所以接下来为结构体配置-targetasc-然后调用刚刚创建的函数--applydamageeffect)
    - [现在重构完成，在不影响之前功能的前提下，我们还使用 `SetByCaller` 绑定了 `Debuff 参数` 的 `Tag` 和 `float`这样我们就可以在计算伤害的时候拿到](#现在重构完成在不影响之前功能的前提下我们还使用-setbycaller-绑定了-debuff-参数-的-tag-和-float这样我们就可以在计算伤害的时候拿到)
    - [测试一下，应该不影响之前的功能](#测试一下应该不影响之前的功能)
    - [下一节处理，通过 `SetByCaller` 拿到 `Debuff 参数` 并计算](#下一节处理通过-setbycaller-拿到-debuff-参数-并计算)



___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[4. Using Damage Effect Params_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=104&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 这一节，我们将使用这个 `(使用结构体的)函数` 来应用伤害


------

### 我们打开生成火球的GA `AuraProjectileSpell`

  - 1.我们在这里配置了 火球携带的信息

  - 2.然后让火球携带了 `Spec`
>![img](./Image/GAS_151/25165450_bdc54dfc-d8e0-4561-f24e-8762186dc1a1.png)

  - 这里的功能好多都是出于演示的目的，并没有实际用到


------

#### 需要重构这里的逻辑，使用刚刚创建的函数 `ApplyDamageEffect`，而且之前的火球携带的 `Spec` 后面也不需要携带了，直接携带上面创建一堆参数的结构体 `FDamageEffectParams` 就行

  - 命名为，`DamageEffectParams`
>![img](./Image/GAS_151/25165450_0cb02019-b469-49b3-b52d-be03074440fb.png)
>![image-20241006231344600](./Image/GAS_151/image-20241006231344600.png)
>![image-20241006231431545](./Image/GAS_151/image-20241006231431545.png)

- 这样就完成了
>![image-20241006231939064](./Image/GAS_151/image-20241006231939064.png)

------

#### 接下来修复报错


------

##### 先抽象一下，复用的逻辑
>![image-20241006232355236](./Image/GAS_151/image-20241006232355236.png)

------

###### 使用Rider的便捷抽象功能
>![image-20241006232438597](./Image/GAS_151/image-20241006232438597.png)
>![image-20241006232506465](./Image/GAS_151/image-20241006232506465.png)
>![image-20241006232742794](./Image/GAS_151/image-20241006232742794.png)
>![image-20241006232838718](./Image/GAS_151/image-20241006232838718.png)

- 手动调用一下
>![image-20241006233013927](./Image/GAS_151/image-20241006233013927.png)

------

##### 使用 `结构体中的数据` 和 重叠时的 `OtherActor` 判断

> ![image-20241006233415994](./Image/GAS_151/image-20241006233415994.png)

------

##### 压缩代码量

>![img](./Image/GAS_151/25165450_fcb07909-5db6-4d64-ab2a-de5b4ec3baa7.png)
>![img](./Image/GAS_151/25165450_344fc8be-f031-468d-99ae-fd8fba423fb6.png)
>![img](./Image/GAS_151/25165450_7d53a048-9ece-40bb-861f-91dff18f8923.png)
>![img](./Image/GAS_151/25165450_e68b8adb-4318-454a-9e06-b54dc76ce30a.png)

------

#### 因为在这里是重叠发生时，可以拿到 `TargetActor`，所以接下来，为结构体配置 `TargetASC` ，然后调用刚刚创建的函数  `ApplyDamageEffect`
>![image-20241006233532351](./Image/GAS_151/image-20241006233532351.png)

------

### 现在重构完成，在不影响之前功能的前提下，我们还使用 `SetByCaller` 绑定了 `Debuff 参数` 的 `Tag` 和 `float`这样我们就可以在计算伤害的时候拿到
>![image-20241006233624626](./Image/GAS_151/image-20241006233624626.png)

------

### 测试一下，应该不影响之前的功能
------

### 下一节处理，通过 `SetByCaller` 拿到 `Debuff 参数` 并计算
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
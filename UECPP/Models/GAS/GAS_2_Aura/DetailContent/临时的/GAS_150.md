<details>
<summary>过程截图</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 150 GA中添加Debuff参数；创建结构体保存传递要使用的诸多参数；GA中使用上下文设置结构体参数；使用结构体中的信息对目标应用GE

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[2. Debuff Parameters_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=102&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

[3. Damage Effect Params Struct_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=103&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 上一节我们创建了 `Debuff` 的 `FGameplayTag` 标签，如果想要实现 `Debuff` 还需要在 GA 上配置一些变量，比如：

| 变量类型 | 变量名          | 作用                |
| -------- | --------------- | ------------------- |
| `float`  | DebuffChance    | Debuff 触发的概率   |
| `float`  | DebuffDamage    | Debuff 每次的伤害   |
| `float`  | DebuffFrequency | Debuff 多久生效一次 |
| `float`  | DebuffDuration  | Debuff 持续时间     |

  - 上面说的这些，可以自己配表，这里只使用 `float` + `Level` 来简单计算


------

### 在 `AuraDamageGameplayAbility` 中，添加 配置 `Debuff` 的变量

| 变量类型 | 变量名          | 作用                |
| -------- | --------------- | ------------------- |
| `float`  | DebuffChance    | Debuff 触发的概率   |
| `float`  | DebuffDamage    | Debuff 每次的伤害   |
| `float`  | DebuffFrequency | Debuff 多久生效一次 |
| `float`  | DebuffDuration  | Debuff 持续时间     |

>![img](https://api2.mubu.com/v3/document_image/25165450_b65e9418-0439-4425-eba8-c2f3be153bd0.png)

------

### 接下来，需要考虑，如何传递GA中的这些消息


------

#### 这里希望使用 `SetByCaller` 来绑定对应 `FGameplayTag` 和 `float`

  - 所以需要创建对应 `FGameplayTag`


------

#### 创建 `Debuff` 的变量 对应 `FGameplayTag`
>![img](https://api2.mubu.com/v3/document_image/25165450_07c67b58-1e06-4846-8698-6b6b55a1375b.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_86c56df2-ce63-441b-802c-78d3a66ce6c6.png)

------

#### 我们之前在创建火球的Actor时，绑定了 `伤害类型` 和 `伤害` 的 `SetByCaller`，然后在 `ExecCalc_Damage` 中遍历获取，然后计算对应的属性抗性
>![img](https://api2.mubu.com/v3/document_image/25165450_800ee4e4-f70e-4d6c-8c8e-0369ca1010f9.png)

------

### 下一节，处理


------

### 随着后面的处理越来越多的参数，如果手动配置大量的参数，会越来越麻烦。现在打算创建一个自建结构体的数据结构，当调用函数时，根据上下文配置大部分参数，方便使用


------

#### 在 `AuraAbilityTypes` 中，创建结构体

  - 我们之前在这个文件中创建了自己的 `FGameplayEffectContext`
>![img](https://api2.mubu.com/v3/document_image/25165450_350bb53e-2078-48b0-c1da-a4afb67a21b5.png)

- 命名为，`FDamageEffectParams`

- 保存如下参数：

  | 变量类型                      | 变量名                       | 作用               |
  | ----------------------------- | ---------------------------- | ------------------ |
  | `UObject`                     | WorldContextObject           | 世界上下文         |
  | `TSubClassOf<UGmaplayEffect>` | GmaplayEffectClass           | 伤害的GE_Class     |
  | `UAbilitySystemComponent`     | SourceAbilitySystemComponent | 源对象的ASC组件    |
  | `UAbilitySystemComponent`     | TargetAbilitySystemComponent | 目标对象ASC组件    |
  | `float`                       | BaseDamage                   | 技能的伤害值       |
  | `int32`                       | AbilityLevel                 | 技能等级           |
  | `FGameplayTag`                | DamageType                   | 技能的属性伤害类型 |

  - 以及 四个Debuff的参数：

  | 变量类型 | 变量名          | 作用                |
  | -------- | --------------- | ------------------- |
  | `float`  | DebuffChance    | Debuff 触发的概率   |
  | `float`  | DebuffDamage    | Debuff 每次的伤害   |
  | `float`  | DebuffFrequency | Debuff 多久生效一次 |
  | `float`  | DebuffDuration  | Debuff 持续时间     |


>![img](https://api2.mubu.com/v3/document_image/25165450_b162eace-6445-469e-c079-965e4f830cbf.png)

------

#### 在 `AuraDamageGameplayAbility` 中，创建函数，根据上下文设置结构体的变量

  - 命名为，`MakeDamageEffectParamsFromClassDefaults`

  - 形参为：`TargetActor` 因为可能调用这个函数时(初始化时)没有Target，比如远程技能火球创建时并不知道Target，所以给一个默参 `nullptr`
    - 这样可以在后面参数变化时，手动设置 `TargetActor` 

  - 返回结构体，所以需要引入头文件
>![img](https://api2.mubu.com/v3/document_image/25165450_b2fb7b47-6835-4cd9-f51e-2c09e2bc758a.png)

------

##### 函数体内，创建结构体，然后 根据上下文逐一设置，然后返回该结构体

- 因为调用了ASC函数库的静态函数，判断目标是否实现了ASC组件，本来想在函数外判空指针，查看源码发现，该静态函数内已经判空，所以直接调用即可
>![img](https://api2.mubu.com/v3/document_image/25165450_6def8aba-e561-4833-d9e0-c5449b440cd1.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_61ec44c3-e137-4b88-c217-2ca355c383f3.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_c3e75979-77ec-469f-9503-f6c8832963ba.png)

- 设置完返回结构体即可
>![img](https://api2.mubu.com/v3/document_image/25165450_954e01c0-e94e-45b6-d7d0-87da07cfa4f4.png)

------

### 小测试1

  - 在蓝图函数库中创建一个静态函数，形参使用上面创建的结构体，然后绑定 `SetByCaller` ，之后对目标应用GE效果
>![img](https://api2.mubu.com/v3/document_image/25165450_2e6213c2-6a08-4f27-e3e7-4c957389285d.png)

------

### 自己尝试一下


------

#### 蓝图函数库中创建一个静态函数

  - 函数命名为，`ApplyDamageEffect`

  - 返回值可能使用到 `FGameplayEffectContextHandle` 所以需要返回该类型
>![img](https://api2.mubu.com/v3/document_image/25165450_bee9882d-7ade-4e12-9321-bcf628c5f746.png)

------

#### `ApplyDamageEffect` 函数体内，获取 `ASC` ，1.创建 `Context` ；2.创建 `Spec` ；3.添加 `SourceActor` ；4.绑定 `SetByCaller` ；5.应用 `Spec` ；6.返回
>![img](https://api2.mubu.com/v3/document_image/25165450_a1c4af9f-2d06-4b54-e796-e567aa53f74f.png)

------

##### 其中绑定 `SetByCaller` 时，不光要绑定 `伤害` 和 `属性伤害类型` ，还需要绑定 `Debuff变量` 和 `Tag`
>![img](https://api2.mubu.com/v3/document_image/25165450_fab68896-8904-419e-83a8-17f2e8f27816.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_8db870b8-75b1-4b3d-91cb-2a7cac685222.png)

------

##### 最后返回 `FGameplayEffectContextHandle` 
>![img](https://api2.mubu.com/v3/document_image/25165450_870c61aa-be50-4812-8139-ad88f0bbdf04.png)

------

### 下一节，我们将使用这个 `使用结构体的 函数` 来应用伤害
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
<details>
<summary>过程截图</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 154 在C++中创建并应用Debuff的GE流程（期间读取Context中的配置设置GE参数）；处理敌人死亡时不应用Debuff

___________________________________________________________________________________________

## 处理关键点

1. 在C++中创建GE 配置的步骤流程！！！
2. `TSharedPtr` 中 `MakeShared` 和 `MakeSharedAble` 的区别？

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[8. Dynamic Gameplay Effects_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP/?p=108&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 这一节，我们来处理为Debuff在C++中创建GE 配置，然后应用

  - `Stack` 需要设置，同时间只能生效一个 `Debuff` 伤害（这里就是这样设计的，不是可叠加的Debuff）


------

### 首先，如果动态生成GE然后应用，这样是不支持复制的！！所以只能在服务器上处理！！！


------

### 下面是在C++中创建GE 配置，然后应用的顺序


------

#### 第1步：创建 `ContextHandle`


------

#### 第2步：添加 `SourceObject`


------

#### 第3步：`new` 一个新的 `GE`

  - 需要一个名字FName
>![img](https://api2.mubu.com/v3/document_image/25165450_e6070b7a-0a09-4451-8b9a-2c2216dc744a.png)

------

##### 可以使用 `FString::Printf` 使用该次Debuff的FGameplayTag名，格式化创建一个
>![img](https://api2.mubu.com/v3/document_image/25165450_c35c7de1-e3f0-4726-efa1-b29eaeba571d.png)

------

#### 通过蓝图函数库获取该 `Context` 中携带的 `Debuff` 的参数
>![img](https://api2.mubu.com/v3/document_image/25165450_74ec4796-b7bc-4329-a102-b86156530a8c.png)

------

#### 第4步：设置 `DebuffGE` 持续时间类型
>![img](https://api2.mubu.com/v3/document_image/25165450_c5af43ea-3e49-40ef-eed6-a3bf6ce34beb.png)

------

#### 第5步：设置 每隔多久触发一次 `DebuffGE` 伤害
>![img](https://api2.mubu.com/v3/document_image/25165450_d734e760-9aa1-4bc5-9a4c-829e1308b355.png)

------

#### 第6步：设置 `DebuffGE` 伤害
>![img](https://api2.mubu.com/v3/document_image/25165450_7ef39662-f44e-4f35-b465-3e332bdb63d4.png)

------

#### 第7步：( `关键步骤!` )让 `DebuffGE` 携带 `Debuff` 的 `FGameplayTag`

  - 使用API：`Effect->Inheritable0wnedTagsContainer.AddTag` 为GE添加Tag
>![img](https://api2.mubu.com/v3/document_image/25165450_5b8475af-adfa-457e-e6ff-051a50318261.png)

------

#### 第8步：设置 `DebuffGE` 的Stack堆叠 策略和堆叠上限
>![img](https://api2.mubu.com/v3/document_image/25165450_a9030fbf-340a-4e6f-80ae-80f23150a9d0.png)

------

#### 第9步：设置 `DebuffGE` 的触发伤害

  - 要设置伤害，也就是需要往 `Modifiers` 中添加元素


------

##### 可以看到 `Modifiers` 中元素的类型为 `FGameplayModifierInfo`
>![img](https://api2.mubu.com/v3/document_image/25165450_885285e7-84aa-45ce-e80f-894a1177f70d.png)

------

#####  `Modifiers` 中这里只使用了一个元素（也支持添加多个元素）

  - 记录当前数组添加元素 `FGameplayModifierInfo` 后的Index，然后设置该元素 `FGameplayModifierInfo` 的伤害


------

##### 接下来，需要设置 `DebuffGE` 要修改的属性是哪个

  - 因为是伤害，所以直接修改元属性 `InCommingDamage`


------

#### 这样就完成了在服务器上配置GE，接下来该准备应用和传递参数了
>![img](https://api2.mubu.com/v3/document_image/25165450_034e047b-4575-4c3e-f819-7e4c8ffc24f1.png)

------

#### 第10步：应用 `DebuffGE`


------

##### `new` 一个新的 `Spec`
>![img](https://api2.mubu.com/v3/document_image/25165450_626068e2-ff68-437a-f038-c0f116d4f790.png)

------

#### 第11步：需要将 `Context` 强制类型转换成自建的类型（因为要在这里通过 `Context` 传递 `DamageType` 参数）
>![img](https://api2.mubu.com/v3/document_image/25165450_55e2a3c0-cf21-4985-9e91-a391c070a090.png)

------

#### 以上，这样就完成了


------

### 需要注意的是，Debuff会多次触发，所以不要在这里将 `FAuraGameplayEffectContext` 中的是否成功触发设置为true，因为这是首次触发后创建GE的条件（不然就无限循环了！需要注意下！）
>![img](https://api2.mubu.com/v3/document_image/25165450_e51e671f-a96e-4787-9d31-c0424356c88c.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_78effcc3-c814-444b-8110-351b2519efdc.png)

------

### 运行测试gif
>![img](https://api2.mubu.com/v3/document_image/25165450_115511ec-861e-4d76-80c1-fd311698ab57.png)

- 但是有一个问题是，敌人死后 Debuff 还依然存在，可以看到伤害数字ui


------

### 可以在AS的后处理函数中，先判断目标是否死亡
>![img](https://api2.mubu.com/v3/document_image/25165450_2147eb93-d307-440f-c0a7-3e6f3955536a.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_7c97c0b4-989b-4034-e277-18d0276d5c7d.png)

------

### 临时修改触发概率为100%
>![img](https://api2.mubu.com/v3/document_image/25165450_f8e6dd98-eed5-4dda-e6fb-a1e1d902aee0.png)

------

### 运行测试gif
>![img](https://api2.mubu.com/v3/document_image/25165450_6a978ea8-9883-4b7a-cab3-1ae4d369826a.png)

- 这回敌人死了就不会再继续触发了
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
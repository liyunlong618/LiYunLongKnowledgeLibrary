___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 146 点击装备技能的逻辑，(需要记录之前的技能球，移除InputTag，旧的UI还原，新的添加InputTag，两个都需要更新状态Tag)；需要RPC上服务器处理，然后同步给客户端

___________________________________________________________________________________________

## 处理关键点

1. 技能 一定要 **在服务器上处理！！！**
2. 如果涉及到技能列表，该 `加锁` **加锁！！！**
3. 一定要熟悉这个联网流程：
   - **客户端调用 `RPC_Server` 上服务器操作数据，然后再调用 `RPC_Client` 向客户端同步数据！！！**

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[30. Equipping Abilities_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP/?p=97&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________


### 这一节我们来处理，点击 `装备技能区` ，装备 技能 的逻辑，这位我们的新技能分配输入标签和绑定输入


------

### 先来梳理一下，当我们点击 `装备技能区` 的 `技能球` 后会触发的逻辑

  - 需要为技能重新分配输入标签，并清除该 `技能` 和 `技能球` 之前的配置

  - 假如这个技能已经装备，我们需要记录修改之前的技能球，然后将其恢复成无技能的状态

  - 除了装备技能区，更新时，也需要更新 ***WBP_Overlay*** 上的技能UI


------

### 我们先来处理点击，当我们点击 装备按钮 后，需要检查技能的 `状态标签` ，是否为 `已解锁` 和 `可装备` 状态，其他状态无法装备；如果状态没有问题，我们需要保存该技能的 `InputTag` ，这样就能知道这个技能所在的是 `装备技能区` 的哪个技能球（后面叫插槽）

  - 可以在 `WidgetController` 上持有该 `InputTag` ，叫 `插槽`


------

#### 在 `SpellMenuWidgetController` 中保存该 `插槽`

  - 命名为，`SelectedSlot`

>![img](https://api2.mubu.com/v3/document_image/25165450_6e10588e-4f72-4b7c-fe54-3047547672dd.png)


------

#### 我们需要检查该技能的技能状态


------

##### 我们需要获得的是 `技能` 的 `状态标签` ， `实时的` ，而不是从Select结构体上拿的，所以需要通过 `ASC组件` 拿到

- **而 `ASC组件` 如果想要拿 `状态标签` ，使用之前的函数，则必须要一个 `AbilitySpec`**

>![img](https://api2.mubu.com/v3/document_image/25165450_4a24d34e-87a8-4441-a54f-c53a56762120.png)


------

###### 我们在 `ASC组件` 上创建函数，根据传入的 `AbilityTag` ，获取并返回 `状态标签`

- 命名为，`GetStatusFromAbilityTag`

>![img](https://api2.mubu.com/v3/document_image/25165450_936162f3-c55c-4c4f-9742-d2722fe1c0db.png)


------

###### 调用之前的组合函数即可

>![img](https://api2.mubu.com/v3/document_image/25165450_53cbc61f-82c4-49b3-e3fe-dcb653680c86.png)


------

##### 然后我们就可以拿到 技能 的 `状态标签`

>![img](https://api2.mubu.com/v3/document_image/25165450_56c35c05-2074-40db-9e84-9a65b93c121e.png)


------

#### 然后如果 `技能状态` 是 `已装备的` ，那我们就可以获取 该技能的 `InputTag`

  - **但是 `ASC` 中的函数也是根 `据AbilitySpec` 获取 `InputTag`**


------

##### 所以也需要在ASC中创建一个函数，根据 `AbilityTag` ，返回对应的 `InputTag`

- 命名为，`GetInputTagFromAbilityTag`

- **还是调用组合函数**

>![img](https://api2.mubu.com/v3/document_image/25165450_cba0fa2c-b245-462c-dd9a-6e1ab6cdca65.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_6e1cb1b9-b3f0-48c3-ec76-3aa3e6c6184b.png)


------

##### 这样就拿到了 `InputTag`

>![img](https://api2.mubu.com/v3/document_image/25165450_af949c0b-ba05-43b3-939e-85c0395268d1.png)


------

#### 当我们点击 `装备技能区` 的技能球后，需要创建一个 BlueprintCallable 蓝图可调用事件，关于需要的参数：

  - 命名为，`SpellRowGlobePressed`

##### 首先， `装备技能区` 技能球上是不知道自己是主动技能还是被动技能的现在，所以需要加一个 `配置标签` ，

##### 然后，技能球有自身所表示的技能的 `AbilityTag` 可以作为参数传入

>![img](https://api2.mubu.com/v3/document_image/25165450_9f4d15e0-7d50-48a6-8087-33b9df51ce2c.png)


------

#### 函数体中的逻辑处理：


------

##### 首先，如果 `bWaitingForEquipSelection == false` （不是在点击装备按钮进入装备技能状态）说明不是要装备技能时点击，不能触发逻辑


------

##### 其次，不能在 主动技能 `插槽` 中 装备 被动技能 ，反之亦然 


------

##### 然后拿到选择技能的 `技能类型` （通过结构体）

>![img](https://api2.mubu.com/v3/document_image/25165450_84a65f7b-2662-4b13-89fd-7fbdc744dd9e.png)


------

###### 如果 `技能类型` 与 `技能球` 的 `技能类型` 一致，才能处理逻辑


------

#### 接下来，需要 `ASC上服务器` 修改 `技能的标签`

  - **需要两个参数：**

    - **技能标签**

    - **输入标签**


------

##### ASC中创建 `RPC_Server` 函数

  - 命名为， `ServerEquipAbility`

>![img](https://api2.mubu.com/v3/document_image/25165450_7b595348-6e77-4fe2-d79d-ad728b3ae629.png)


------

###### 需要先检查该技能是否有有效的 `AbilitySpec`

  - **因为我们之前处理了逻辑，当技能解锁后花费点数，学习技能（添加到可激活的技能表中）**

  -**拿到该技能的 `输入标签` 和 `状态`**


------

###### 然后检查该技能状态是否有效（也就是是否为 `已解锁` 和 `已装备` 状态）

>![img](https://api2.mubu.com/v3/document_image/25165450_f15ba4e8-c274-43a8-dea2-2a31d871e545.png)


------

###### 接下来，我们需要在 `Spec` 中移除 `指定的标签` ，需要创建一个函数

  - 命名为，`ClearSlot`

  - 需要先移除某个动态标签，使用动态标签API移除

  - 然后调用API同步 `AbilitySpec`

>![img](https://api2.mubu.com/v3/document_image/25165450_766bf453-9d13-4c39-efba-d5bdcd31d48d.png)

>![img](https://api2.mubu.com/v3/document_image/25165450_602ca82e-1800-4f80-cedd-76d62f653f82.png)


------

###### 创建函数：检查 `技能` 是否含有 `某个标签`

  - 命名为，`AbilityHasSlot`

  - **遍历检查动态标签中，是否包含指定 `Slot` 标签**

  - **因为是纯操作数据，所以可以改成 `Static` 函数**

>![img](https://api2.mubu.com/v3/document_image/25165450_7daccb33-df7d-4a95-b7c7-272a72e96a6e.png)

>![img](https://api2.mubu.com/v3/document_image/25165450_f9a29ff6-f1f9-4a72-9ff2-d21032b7751e.png)


------

###### 创建调用上面两个函数的函数： 检查所有已激活技能表，调用 `AbilityHasSlot` 检查是否含有某个标签，然后调用 `ClearSlot` 移除（因为遍历了已激活技能列表，所以需要使用技能列表锁！！！）

  - 命名为，`ClearAbilitiesOfSlot`

  - 遍历已激活技能表，是否包含指定 `Slot` 标签，然后移除

  - 在函数开始时，使用 `技能列表锁` 

>![img](https://api2.mubu.com/v3/document_image/25165450_7daccb33-df7d-4a95-b7c7-272a72e96a6e.png)

>![img](https://api2.mubu.com/v3/document_image/25165450_a31cf356-94dc-4952-aeb0-f9a3556ee94e.png)


------

##### 然后会到 `ASC上服务器` 的函数中，“下面假定我们使用 `新技能` 覆盖 `旧技能` 的 `InputTag`”

  - **如果该技能状态有效，则执行移除 `Slot标签`**

>![img](https://api2.mubu.com/v3/document_image/25165450_b1bfc966-ec57-4ae9-9072-b6913d878669.png)


------

###### 第一步：我们先 移除所有 拥有 `新的输入标签（Slot）` 上的 `技能`

  - 这样所有技能都不会有新的 `Slot` 的 `InputTag`


------

###### 第二步：清除 新技能 的 `InputTag`


------

###### 第三步：为 新技能 的 `Spec` 添加新的 `InputTag` 动态标签


------

###### 这时候需要检查，如果该技能状态是 `未装备` ，需要 移除 ，然后换成 `已装备`

>![img](https://api2.mubu.com/v3/document_image/25165450_47f04c81-d252-4dec-830d-e0a929ecfe72.png)


------

##### 最后别忘了要 `使用API立即同步一下！！！`

>![img](https://api2.mubu.com/v3/document_image/25165450_546fc124-3e2f-4eb2-e781-7e3e0d894361.png)


------

#### 现在我们完成了服务器上的逻辑，还需要一个 `RPC_Client` 函数来 通知 客户端


------

##### `ASC` 上创建 `Client函数` ，传递参数

  - `AbilityTag`

  - `StatusTag`

  - `InputTag`

  - `上一个技能的 InputTag`

>![img](https://api2.mubu.com/v3/document_image/25165450_34e27f6a-16b3-44a4-ba74-5597b353e0c9.png)


------

#### 服务器上函数体最后需要调用 `RPC_Client` 函数来 通知 客户端

>![img](https://api2.mubu.com/v3/document_image/25165450_9aa73415-e728-4b31-baed-2e70dddfe7a8.png)


------

####  `RPC_Client` 函数中需要创建多播来广播这 四个参数

  - 命名为，`FAbilityEquipped`

>![img](https://api2.mubu.com/v3/document_image/25165450_b9e0b698-2ac1-4686-9556-53969dd392c4.png)


------

##### 声明委托实例

  - 命名为，`AbilityEquipped`

>![img](https://api2.mubu.com/v3/document_image/25165450_57412ec0-4eb2-487e-d651-3136911b5517.png)


------

##### 广播

>![img](https://api2.mubu.com/v3/document_image/25165450_ae7b6834-03c7-44ab-e86c-fc8fb678d4a8.png)


------

### 在 `SpellMenuWidgetController` 中创建该委托的回调

  - 命名为，`OnAbilityEquipped`

>![img](https://api2.mubu.com/v3/document_image/25165450_f14b14f1-d1fd-4442-a081-062e5fa1edc7.png)


------

#### 在 `BindCallbacksToDependencies` 函数中绑定回调

>![img](https://api2.mubu.com/v3/document_image/25165450_6190b027-dac2-4e4d-ca77-b34e1b038cca.png)


------

#### 接下来处理回调函数中的逻辑


------

##### 我们需要将前一个技能球的信息设为空，然后广播，后一个在广播修改后的数据


------

##### 先将 `bWaitingForEquipSelection` 设为false

  - **标识这一段逻辑的闭环**


------

##### 使用之前的 `选择技能球的结构体` ，创建一个 `局部变量` ，如果我们选择的 `技能状态` 是 `已装备技能`，就需要向前一个技能球广播空数据，否则不用向前一个广播，然后 `广播修改后的技能球` ，最后，还需要让播放 `装备技能区` UI的动画停止的广播

>![img](https://api2.mubu.com/v3/document_image/25165450_07b9c6f1-bfca-4e1b-bc59-1bcf213e8205.png)

- 这里的逻辑没有判断之前选中技能球的状态


------

#### 接上之前的逻辑，我们需要在按下 `装备技能区` 的技能球触发的 BlueprintCallable 函数 `SpellRowGlobePressed` 中调用 `RPC_Server` 函数

>![img](https://api2.mubu.com/v3/document_image/25165450_2bdfc3e8-bc91-49e5-8164-a780636e262d.png)


------

### 梳理一下整体逻辑：

<details>
<summary>这里梳理一下整体流程逻辑：</summary>

># 整体流程：
>
>  - 在 `SpellMenuWidgetController` 的 `SpellRowGlobePressed` 函数中，如果，在播放 `装备技能的动画` ，且选中技能与 `点击区插槽的技能` 类型一致，就调用ASC的函数 `ServerEquipAbility` ，上服务器
>
>  - （这里假设使用新技能覆盖旧技能输入Tag）ASC服务器函数 `ServerEquipAbility` 中，检查技能类型，若无误，将包含 `InputTag` 的技能移除该输入Tag，然后为新技能添加该 `InputTag` ，此时如果技能是已解锁状态，还需要把 `已解锁状态` 的Tag移除后换成 `已装备状态` Tag，调用API立即同步一下Spec数据，然后调用 `RPC_Client` 函数 `ClientEquipAbility` 通知指定客户端
>
>  - `RPC_Client` 函数 `ClientEquipAbility` 中，广播数据到UI 的 `SpellMenuWidgetController` 中
>
>  - `SpellMenuWidgetController` 中，初始化时绑定回调，这样触发回调函数时，先向旧的插槽中广播空数据清空图标，再向新插槽中广播新数据，然后调用关闭 `装备技能的动画` 的广播
>
>
># 每一步解释：
>
>  - 在 `SpellMenuWidgetController` 的 `SpellRowGlobePressed` 函数中，如果，在播放 `装备技能的动画` ，且选中技能与 `点击区插槽的技能` 类型一致，就调用ASC的函数 `ServerEquipAbility` ，上服务器![img](https://api2.mubu.com/v3/document_image/25165450_050fc08f-9394-4701-afa3-ac6aa9235db8.png)
>  - （这里假设使用新技能覆盖旧技能输入Tag）ASC服务器函数 `ServerEquipAbility` 中，检查技能类型，若无误，将包含 `InputTag` 的技能移除该输入Tag，然后为新技能添加该 `InputTag` ，此时如果技能是已解锁状态，还需要把 `已解锁状态` 的Tag移除后换成 `已装备状态` Tag，调用API立即同步一下Spec数据，然后调用 `RPC_Client` 函数 `ClientEquipAbility` 通知指定客户端![img](https://api2.mubu.com/v3/document_image/25165450_6d774acf-f891-40e2-f3c6-69099119e9c4.png)
>
>  - `RPC_Client` 函数 `ClientEquipAbility` 中，广播数据到UI 的 `SpellMenuWidgetController` 中![img](https://api2.mubu.com/v3/document_image/25165450_6da37a0f-9fdc-4a01-9273-97eb848429d0.png)
>
>  - `SpellMenuWidgetController` 中，初始化时绑定回调，这样触发回调函数时，先向旧的插槽中广播空数据清空图标，再向新插槽中广播新数据，然后调用关闭 `装备技能的动画` 的广播![img](https://api2.mubu.com/v3/document_image/25165450_9dbd45ad-3e67-49b2-f843-644977bc9c8c.png)

------

</details>

------

### 蓝图中 为插槽配置 `技能类型`

>![img](https://api2.mubu.com/v3/document_image/25165450_dba802e3-9217-4def-8c3f-4fe423a12e0e.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_8c7284f5-e3c0-4f4f-e852-0a49be565897.png)


------

### 插槽的UI中，调用

>![img](https://api2.mubu.com/v3/document_image/25165450_6e5ebaf2-25ca-4f0e-edba-896ba939a5cf.png)


------

### 这个时候运行应该有个bug

  - 装备技能后，除了火球和闪电技能，所有图标都被修改了
    - 因为被修改的都是技能的图标被配置为 `None` 的

- 因为都是这么设置的

>![img](https://api2.mubu.com/v3/document_image/25165450_3003d164-427f-4c56-ae08-5720f7226f2e.png)

>![img](https://api2.mubu.com/v3/document_image/25165450_ee21479d-2005-49e3-8c97-6f998f28d7f3.png)


------

#### 需要将 `技能Tag` 设置为空（就是不选）

>![img](https://api2.mubu.com/v3/document_image/25165450_4b4779cd-d57a-4abd-e194-f5a4f2e45d32.png)


------

#### 这个时候再装备技能，发现被修改过的就好了

>![img](https://api2.mubu.com/v3/document_image/25165450_1edf5b94-153d-469f-c214-2814b34c839a.png)


------

#### 将被动技能也设置一下

>![img](https://api2.mubu.com/v3/document_image/25165450_ba02c360-0b86-436c-e427-bd9ae85688bf.png)


------

### 但是对于已装备技能的插槽，我们之前的逻辑在这里，需要修改下

>![img](https://api2.mubu.com/v3/document_image/25165450_d0122241-760d-43d6-8a2e-2ab2d3acddfe.png)


------

#### 假如接受的 `AbilityTag` 为 `None` ，需要 `手动配置` 要使用的贴图

>![img](https://api2.mubu.com/v3/document_image/25165450_2ccdf05a-f4ad-433e-a13b-93753b3e01cc.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_13d97b43-debb-4b1e-922d-857e2c8a2ce1.png)


------

### 在测试就正常了 gif

>![img](https://api2.mubu.com/v3/document_image/25165450_0267a153-2efd-4dba-812f-9a32b90520f7.png)


------

### 有一个bug是，当我们装备新的技能后会清空其余的所有技能

>![img](https://api2.mubu.com/v3/document_image/25165450_96a67345-9bd0-470e-f651-e14001e7ee4a.png)


------

### 下一节，处理


___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
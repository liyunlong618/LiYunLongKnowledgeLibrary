___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 161 GA中使用GAS异步节点  `WaitInputPress` 等 监听输入按键状态（需要在源码中将事件和按键同步服务器）

___________________________________________________________________________________________

## 处理关键点

1. GA中有异步函数可以监听鼠标 `按下` `松开` 的状态

2. 当我在GA开始时调用 `WaitInputRelease` ,收不到监听，但是在GA激活时可以打印，是因为我激活技能时调用的 `AbilitySpecInputReleased(AbilitySpec);` ，没有调用 `InvokeReplicatedEvent`

    - 所以但如果要监听，需要获取技能状态，需要通过服务器

    - 当一个技能在客户端被激活时，通过 `Spec.IsActive()`  知道该技能正在被激活后，调用函数 `InvokeReplicatedEvent` 将这个消息同步并由服务器进行验证，或者广播给其他客户端。

3. 释放持续引导类技能 制作思路：

    - 施法前摇使用 `蒙太奇` 制作

    - 后半段持续施法使用 `状态机` 制作

    - 如果涉及网络，同步数据需要使用 `属性复制` ！

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[5. Invoke Replicated Event_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP/?p=118&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 接下来我们将开始着手制作我们的 `闪电技能`

  - 这个技能释放后我们会处于一个持续施法的状态，当我们松开按键后，停止施法

- 我们会使用这个NS特效
>![img](https://api2.mubu.com/v3/document_image/25165450_dd1339ae-9036-4bcb-cf87-a1c125ac28a8.png)

- 使用这个动画
>![img](https://api2.mubu.com/v3/document_image/25165450_f077e6f4-fdf6-4ebf-dc45-4c2ebc60a619.png)


------

### ***BP_Aura*** 中创建bool 变量

  - 命名为：`InShockLoop`

>![img](https://api2.mubu.com/v3/document_image/25165450_5eece7ff-5588-47be-d242-1b34ccdf47d6.png)


------

### ABP中创建一样的bool变量
>![img](https://api2.mubu.com/v3/document_image/25165450_8787f575-5a8f-4c9a-c7fd-d569322e7956.png)


------

### ABP中设置过渡状态
>![img](https://api2.mubu.com/v3/document_image/25165450_51efc342-0b65-47be-d9fb-0827c8acf473.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_8f713cb2-83b2-4234-ecea-450c6f152630.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_f999fb3a-2bb8-4184-bc9f-52810932dafa.png)


------

### 接口  中创建接口函数，设置bool（因为变量是蓝图中的，需要蓝图实现这个函数）

  - 函数命名为：`SetInShockLoop`

>![img](https://api2.mubu.com/v3/document_image/25165450_17dc7213-2e5d-4d5f-ac3b-98a67dfe22fa.png)


------

### GA中有异步函数可以监听鼠标 `按下` `松开` 的状态
>![img](https://api2.mubu.com/v3/document_image/25165450_2320f88b-c339-40d0-a040-05fd84ee2e57.png)


------

### 为了方便测试，我们在 ***BP_Aura*** 中添加闪电技能为初始技能，并在GA中设置初始输入Tag为 `RMB`
>![img](https://api2.mubu.com/v3/document_image/25165450_9d6f04f7-ef07-48ce-d424-9377f9ed9667.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_368f5d35-958f-46e2-a83b-f018ab4c03db.png)


------

### 测试是否可以收到监听
>![img](https://api2.mubu.com/v3/document_image/25165450_bbeb82e9-f6a9-4515-d688-1e2e3696595c.png)


------

#### 应该是收不到消息，只能收到前面这个打印


------

### 必须确保重量输入释放有效，所以我们必须这样做


------

#### 首先在ASC组件 的松开按键的函数中，需要检查，技能是否为激活状态
>![img](https://api2.mubu.com/v3/document_image/25165450_a2a94bf4-74b7-41f5-a867-8cf1d8f73f45.png)


------

##### ASC组件中 `AbilitySpec.IsActive()` 这个激活是什么意思？是已经学习的技能吗
>![img](https://api2.mubu.com/v3/document_image/25165450_6ff20b14-00e1-4bd4-bbbc-4b009d449b37.png)


------

#### 然后调用函数 `InvokeReplicatedEvent`
>![img](https://api2.mubu.com/v3/document_image/25165450_3b816362-df57-4fbb-8939-c5908d6b1ffc.png)


------

##### 使用场景：当玩家在客户端触发了一项游戏能力，这个函数可以确保该能力事件被正确同步到服务器，并由服务器进行验证或广播给其他客户端。
>![img](https://api2.mubu.com/v3/document_image/25165450_f2e465ee-e666-42df-d634-029731df2c29.png)


------

### 所以综上所述，当一个技能在客户端被激活时，通过Spec.IsActive() 知道该技能正在被激活后，调用函数 `InvokeReplicatedEvent` 将这个消息同步并由服务器进行验证，或者广播给其他客户端。
>![img](https://api2.mubu.com/v3/document_image/25165450_fd01f655-3649-4138-ccfe-337c2fb910fc.png)


------

### 打算在ASC中制作一个函数供PC中的 `AbilityInputTagPressed` 来调用，避免多次触发

  - 创建函数命名为：`AbilityInputTagPressed`

>![img](https://api2.mubu.com/v3/document_image/25165450_85afa2ae-33ea-4ff5-da45-f1f90d0d7902.png)


------

#### 复制 `AbilityInputTagHeld` 逻辑到 `AbilityInputTagPressed` 中
>![img](https://api2.mubu.com/v3/document_image/25165450_aa106078-d3fe-4ad2-8361-e2c97b9d3e0b.png)


------

#### 区别是，这次是检查技能是否激活，激活的话，调用函数 `InvokeReplicatedEvent` 同步服务器
>![img](https://api2.mubu.com/v3/document_image/25165450_461ead3c-ae53-4d47-c973-5196b3036411.png)


------

#### 然后PC的 `AbilityInputTagPressed` 函数中调用ASC的同名函数
>![img](https://api2.mubu.com/v3/document_image/25165450_9c54a486-ddb4-46d7-9553-99bdb0562cc8.png)


------

### 测试一下，我们会在松开按键后，触发监听了
>![img](https://api2.mubu.com/v3/document_image/25165450_5d754645-bc5a-4e9b-d9a4-9f5cfe1a460f.png)


------

### 监听按键按下
>![img](https://api2.mubu.com/v3/document_image/25165450_4bbfe091-24e8-40ef-a2d4-7d9b40b3b4c8.png)


------

### 运行测试gif
>![img](https://api2.mubu.com/v3/document_image/25165450_608d604c-c16e-46d3-e1a1-aa5b88619112.png)


------

### ASC组件的Pressed函数中断点测试，是否只执行一次
>![img](https://api2.mubu.com/v3/document_image/25165450_204bf7d4-dd2e-4aee-923f-f2aff4a61f60.png)


------

### 最后是对于 GAS_159 中问题的修复

___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
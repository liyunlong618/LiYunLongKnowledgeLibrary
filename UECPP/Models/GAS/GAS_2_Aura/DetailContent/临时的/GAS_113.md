<details>
<summary>过程截图</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 113 创建技能图标MVC的逻辑；函数中创建代理实例绑定lambda回调，另一个类中循环广播代理多次触发lambda回调

___________________________________________________________________________________________

## 处理关键点

1. 111111111111111111111111111111

2. 222222222222222222222222222

3. 33333333333333333333333333

4. 4444444444444444444444444444

5. 555555555555555555555555555555

6. 666666666666666666666666666

7. 77777777777777777777777777777777

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[5. Ability Info Data Asset_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=37&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

[6. Initialize Overlay Startup Abilities_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=38&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

[7. For Each Ability Delegate_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=39&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 关于技能的面板我们可以参考之前做过的属性面板的信息收发方式，也创建一个 `DataAsset` 用来配置结构体信息


------

### 可以创建一个自定义的类，来管理创建自己的 `UELOG` 类


------

#### 新建文件，命名为，`AuraLogChannels.h`

> 必须要加的
>
> -  `#pragma once`
>
> -  `#include"CoreMinimal.h"`
>
> 使用宏 `DECLARE_LOG_CATEGORY_EXTERN(LogAura, Log, ALL);` 创建自定义Log名
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_53400583-279e-4dd3-c605-d38b0a56b596.png)
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_5d3ce128-2c8c-40e9-d50e-cb09b7d44957.png)


------

#### 新建文件，命名为，`AuraLogChannels.cpp`

> 需要引用头文件
>
> 使用宏 `DEFINE_LOG_CATEGORY(LogAura)`
>
>   - ![img](https://api2.mubu.com/v3/document_image/25165450_f813c2ca-9585-485e-8153-2c812a8bbd9b.png)


------

### 创建 `DataAsset` 的C++类
>![img](https://api2.mubu.com/v3/document_image/25165450_6a622d6c-d278-483f-e718-77c164dae390.png)


------

### 先梳理一下，我们需要这个结构体中包含的信息

>   - 一个技能的 `FGameplayTag`
>
>   - 一个输入的 `FGameplayTag`
>
>   - 一张技能对应的贴图 `UTexture2D`
>
>   - 一个对应的材质，技能属性的背景(比如火属性、奥数属性技能背景不同) `UMaterialInterface`


------

### 创建结构体，命名为，`FAuraAbilityInfo`，输入Tag因为实在C++中指定的，所以也想在C++中处理，所以不暴露给蓝图
>![img](https://api2.mubu.com/v3/document_image/25165450_f55b3cbb-0155-4479-9387-0e187af87357.png)


------

### 接下来需要创建一个结构体数组用来包含上面的信息
>![img](https://api2.mubu.com/v3/document_image/25165450_b0afa215-c1bd-49fa-eefb-eb4c2a0c5b06.png)


------

### 需要创建一个根据传入的技能Tag查找结构体并返回的函数，当然，如果没有找到，我希望能输出一条警告

> 函数命名参考 `FindAbilityInfoForTag`
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_a3eac6ac-6cf6-4a2d-8733-a115f807484a.png)
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_333d161c-8d77-4e23-fbfd-971fb4623c49.png)![img](https://api2.mubu.com/v3/document_image/25165450_127319ef-9180-451c-c425-06176ab27763.png)


------

### 接下来需要在 `OverlayWidgetController` 中使用，所以，需要持有这个 `DataAsset` 指针
>![img](https://api2.mubu.com/v3/document_image/25165450_8e83413c-6bf1-433d-abc0-dd96beb37079.png)


------

### 创建技能Tag，需要带有属性攻击的前缀，比如`Abilities.Fire.FireBolt`
>![img](https://api2.mubu.com/v3/document_image/25165450_db085c5d-4a43-4f26-8f1c-21717bd000cb.png)![img](https://api2.mubu.com/v3/document_image/25165450_7544cb21-ce07-41e8-a935-eab9f7f8fbab.png)


------

### 蓝图中创建这个数据资产的蓝图类，命名为，`DA_AbilityInfo`，配置参数，并在 `OverlayWidgetController` 蓝图类中配置
>![img](https://api2.mubu.com/v3/document_image/25165450_714d9fbc-75c7-44fd-81e5-a56ee566858e.png)![img](https://api2.mubu.com/v3/document_image/25165450_d47a00aa-11a6-4546-cd37-90bd897ab56e.png)![img](https://api2.mubu.com/v3/document_image/25165450_72581114-17a9-46c7-d25a-3904dc06d1cc.png)


------

### 这样我们就可以广播该结构体


------

### 下一节


------

### 想使用MVC，需要，让 `ASC` 和 `OverlayWidgetController` 之间建立通信，这样每当我们给予  `ASC`  `GA` 时，所给予的能力就可以被广播。


------

#### 现在这可以是一个常规的普通委托，因为只在C++中使用


------

##### 在ASC中创建一个多播
>![img](https://api2.mubu.com/v3/document_image/25165450_29c4448d-3c1b-43b7-9ceb-2a880d171612.png)![img](https://api2.mubu.com/v3/document_image/25165450_f1d7105e-61af-4ac6-9b2e-b5e687518d85.png)


------

#### 我们之前在 `ASC` 的 `AddCharacterAbilities` 函数中，给予目标 `ASC` 技能，可以在这里广播
>![img](https://api2.mubu.com/v3/document_image/25165450_e4e07714-4934-4c25-9058-f179445e5c23.png)


------

#### 我们之前在 `OverlayWidgetController` 的 `BindCallbacksToDependencies` 函数中，处理了绑定委托，因为有强依赖顺序，所以也需要在这里写绑定委托


------

##### 创建回调用的函数，一旦我们知道能力系统已完成所有启动，我们就会调用它
>![img](https://api2.mubu.com/v3/document_image/25165450_45f51494-6c6b-48bd-ac0f-8d682388f852.png)


------

##### `BindCallbacksToDependencies` 函数中原来的逻辑是这样的，需要修改
>![img](https://api2.mubu.com/v3/document_image/25165450_a42e4349-9425-48f4-9124-8c391cb64eea.png)![img](https://api2.mubu.com/v3/document_image/25165450_a375269a-e81c-4e57-fc9a-a65da94567d0.png)


------

### 现在我们一旦给予GA就会触发回调，但是需要考虑执行的先后顺序，我们假定，先绑定，然后给予技能 `GA` ，然后进行广播。根据服务器与客户端上发生的情况等，它可能会有所不同。可能有两种情况：

> 正常我们设想的情况是：先绑定，然后给予技能 `GA` ，然后进行广播
>
> 第二种情况是：假如上来就给与了技能GA，然后广播，但此时还没有绑定回调，那这一条消息就漏掉了
>
>   - 过程逻辑![img](https://api2.mubu.com/v3/document_image/25165450_df8558cd-f165-479a-c362-e03344aadaae.png)


------

#### 所以需要在 `ASC` 上创建 bool 变量标识我们在ASC上广播与否。这样在绑定回调时，判定这个变量就可以处理两种情况了
>![img](https://api2.mubu.com/v3/document_image/25165450_cf1c6446-a017-4262-9f42-b900eab739b2.png)![img](https://api2.mubu.com/v3/document_image/25165450_d057b4c1-c5ce-4c86-fcee-fbf9eb99d376.png)![img](https://api2.mubu.com/v3/document_image/25165450_2553a4b6-d91a-4a68-b970-8c933da9bb7e.png)


------

### 另一方面，我们在回调中，需要通过目标的 `ASC` 获取目标的技能信息，所以最好的办法是，修改逻辑，在广播时，传递一个参数
>![img](https://api2.mubu.com/v3/document_image/25165450_48d79508-73f7-480b-9565-46b64e742cee.png)![img](https://api2.mubu.com/v3/document_image/25165450_184f6350-08d5-4646-f9f4-27f75351f12d.png)![img](https://api2.mubu.com/v3/document_image/25165450_2fe28ef9-d97f-4502-89f7-577bc987fe34.png)![img](https://api2.mubu.com/v3/document_image/25165450_2b1ddd67-5fbc-4109-d038-a1bf4426bbff.png)


------

### 我们目前已经实现了，`MVC` 的 `M` 和 `C` 的通信，还缺和 `V` 的通信方式

> #### **现在我们可以在回调中拿到目标的 `ASC` ，需要拿到技能相关的信息，然后广播到 `UI` 中**


------

### 回调中需要先处理数据


------

#### 如果 ASC 没有广播，我们是直接调用的回调函数，此时的数据肯定不是我们想要的，所以这种情况需要判定返回

>   - 之前设计的逻辑![img](https://api2.mubu.com/v3/document_image/25165450_0ad69b25-cdc7-4f28-e32b-5a69b398536a.png)![img](https://api2.mubu.com/v3/document_image/25165450_2553a4b6-d91a-4a68-b970-8c933da9bb7e.png)
>
>
> 判定返回![img](https://api2.mubu.com/v3/document_image/25165450_27bcadcc-d2cc-4be6-a933-acbd1e62d7ab.png)


------

### 下一节


------

### 有一个问题现在我们需要在 `MVC` 的 `C` 中，遍历所有的可激活的 `GA` 并发送广播，理论上是可以的，但是有点违反 `封装` 的特性，下面将使用一种模式，并不是说以后的逻辑都要搞得这样复杂，当开拓思路吧。

> #### **想在ASC上运行，每一个能力都有一个与之绑定的函数。然后遍历所有能力，并调用绑定到该委托的函数**


------

#### 我们将在 `ASC` 中创建一个广播，传递一个参数 `const FGameplayAbilitySpec&`，命名为 `FForEachAbility` 
>![img](https://api2.mubu.com/v3/document_image/25165450_8a44a4db-6be1-4c95-aa27-5e2f10616d85.png)


------

#### 在 `ASC` 中创建一个函数，形参需要传递一个委托的 const引用
>![img](https://api2.mubu.com/v3/document_image/25165450_a25d3e0f-2af9-428d-ba3e-0cbe850d0abf.png)


------

##### 使用到了API：`ExecuteIfBound`

> #### **作用是：如果目标身上有绑定的回调，就激活，如果没有就会返回一个 `false`**
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_f9a25c13-02bb-4c3d-efe1-95bc6a2175e2.png)


------

#### 还有一个需要注意的问题，就是我们循环的技能列表中的每个技能，可能随时被停掉或者激活，所以需要先锁定 `技能列表`，等函数执行完毕后再解锁 `技能列表`，需要使用 **`作用域技能列表锁`** `FScopedAbilityListLock` 类型，这是一种安全处理 `技能列表` 中技能的方式

> #### **需要注意：需要传入的不是指针，而是一个引用**![img](https://api2.mubu.com/v3/document_image/25165450_cdc02015-a6d4-4f7f-833e-16f5116ab6a7.png)


------

#### 回调函数 `OnInitializeStartupAbilities` 中，创建 `FForEachAbility` 代理实例，并为该代理实例绑定 lambda回调

>   - 这样每个技能都会单独的广播，触发多次lambda回调
>
>   - 注意回调的参数


------

#### 回调中需要使用数据资产，调用我们之前创建的查找指定技能Tag，返回包含该Tag的结构体函数

>   - 现在我们需要传入一个**技能标签**，好，现在**技能标签怎么拿？**![img](https://api2.mubu.com/v3/document_image/25165450_bf0c4982-daec-4fc5-e160-fa2f3d1fdba4.png)
>


------

#### 在 `ASC` 上创建，根据 `FGameplayAbilitySpec` 查找并返回技能Tag的函数


------

##### 使用API：`AbilitySpec.Ability.Get()` 拿到 GA ，然后 `GA>AbilityTags` 拿到技能标签Contaner

> #### **因为这里使用的是指针，记得判断空指针**


------

##### 使用 `MatchesTag` 检查标签是否匹配

> [忘了可以看这里](./_GameplayTag_.md)
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_e952754f-4001-449e-dc5a-a0d2247a1c8e.png)


------

##### 这个函数获取参数，返回参数，可以改为 `static` 函数


------

#### 现在就可以给获取结构体的函数传参了
>![img](https://api2.mubu.com/v3/document_image/25165450_9f7fb845-72be-4d10-e512-95e3a6c3de1d.png)


------

#### 接下来需要获取，GA的输入标签，而输入标签是我们在 `动态能力标签` 中配置的

> 如图所示：我们在 `给予GA` 时，往 `GA` 的 `DynamicAbilityTags` 添加了元素![img](https://api2.mubu.com/v3/document_image/25165450_0978ad8e-0d0e-4044-f815-6f9dcdcff170.png)
>
>   - 所以我们需要创建一个获取 `单个` 动态能力标签 `DynamicAbilityTags` 的函数


------

#### 创建一个获取 `单个` 动态能力标签 `DynamicAbilityTags` 的函数
>![img](https://api2.mubu.com/v3/document_image/25165450_844023bd-167e-461e-ee5a-116413f2c440.png)


------

##### 从能力标签规范中可以拿到动态能力标签 `Contaner`

> ```CPP
> const FGameplayAbilitySpec& AbilitySpec;
> AbilitySpec.DynamicAbilityTags;
> ```


------

##### 然后遍历检查， 使用 `MatchesTag` 检查标签是否匹配

> 之前在这里添加了输入标签![img](https://api2.mubu.com/v3/document_image/25165450_fc7c3be3-a7a4-448e-8503-30a3bf22420f.png)
>
> ![img](https://api2.mubu.com/v3/document_image/25165450_6627a2cf-2dac-490c-ea1c-0fe1b6df5cf7.png)


------

#### 然后就可以拿到 `InputTag` 了
>![img](https://api2.mubu.com/v3/document_image/25165450_0fdc3b5d-2d11-4c43-a109-37dff7393a91.png)


------

### 下面需要处理 `MVC`  `V` 和 `C` 通信的逻辑了


------

#### `OverlayWidgetController` 中创建通信用的动态多播，创建多播对象，蓝图实现
>![img](https://api2.mubu.com/v3/document_image/25165450_90ea3875-99df-4ad5-c7ef-7e421d56c9a2.png)![img](https://api2.mubu.com/v3/document_image/25165450_c204a9d9-71f1-4dc5-821f-d2b8a5442ab1.png)


------

#### 回调函数 `OnInitializeStartupAbilities` 中，向蓝图广播 `Info结构体` 
>![img](https://api2.mubu.com/v3/document_image/25165450_0f6a975f-8a4d-484d-e396-7054008bbc66.png)


------

#### 梳理一下逻辑会发现，所有的逻辑都指向了在ASC中创建的委托 `FForEachAbility` ，在ASC中又创建了循环遍历的函数 `ForEachAbility` ，所以，现在只需要调用 `ForEachAbility` 函数，便可以 多次触发 lambda回调 中的逻辑，从而广播结构体 `Info`
>![img](https://api2.mubu.com/v3/document_image/25165450_74a5b18a-0594-4b89-ceb3-30a31e33cb00.png)
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
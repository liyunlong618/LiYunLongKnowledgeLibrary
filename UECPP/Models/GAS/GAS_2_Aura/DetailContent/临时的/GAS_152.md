<details>
<summary>过程截图</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 152 计算准备应用Debuff；为敌人添加属性伤害抗性

___________________________________________________________________________________________

## 处理关键点

1. 需要查一下：懒单例结构体中有一个TMap，构造中为TMap添加元素，使用TMap时元素并没有全部添加完成，请问是因为什么？
___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[5. Determining Debuff_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1L7NP?p=105&spm_id_from=pageDriver&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 现在我们可以在 `ExecCalc_Damage` 中`，获取 `SetByCaller` 
>![img](https://api2.mubu.com/v3/document_image/25165450_4cb6531f-1814-4aae-9aa7-e8c24f63e340.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_d34847f7-92ee-4c74-bd09-5971114e37ae.png)

- 我们可以通过遍历 `FAuraGameplayTags` 中的 `TMap` 拿到所有的 `属性伤害` 和对应的 `Debuff`
>![img](https://api2.mubu.com/v3/document_image/25165450_5baf14a8-73db-45b1-ff38-05ef44f5eb6b.png)

------

### `Spec.GetSetByCallerMagnitude` 函数中，可以设置 `float DefaultlfNotFound` (若没有找到使用的 默认数值)
>![img](https://api2.mubu.com/v3/document_image/25165450_903c55b1-b743-487b-d039-0ab9ecc74261.png)

  - `DefaultNotFound` 可以给 -1，便于后面从逻辑上识别(但是因为是浮点值，可能会有误差，使用时可以使用 `> 0.5 这样的判断` )
>![img](https://api2.mubu.com/v3/document_image/25165450_4c545013-10f3-4b86-f368-d1a9c23b4290.png)

------

### 如果，可以拿到有效的 `属性伤害` 的 `SetByCaller` 的 `float`


------

#### 通过 `SetByCaller` 拿到 `Debuff的概率` 参数
>![img](https://api2.mubu.com/v3/document_image/25165450_d9e7e56d-ba8a-447a-c8d8-2ca2146d172d.png)

------

#### 我们之前在  的懒单例结构体构造中，为TMap赋值，一一映射了 `<属性抗性,对应的捕获Def>`
>![img](https://api2.mubu.com/v3/document_image/25165450_981d6708-b287-454c-a0c3-836383608004.png)

------

#### 这里解释一下：我们使用了三个TMap分别映射

  - `属性伤害抗性` 和 `对应捕获属性抗性的Def`
>![img](https://api2.mubu.com/v3/document_image/25165450_0d094bbf-d36f-413d-e756-4109e4e99bd5.png)

  - `属性伤害` 和 `对应属性伤害抗性`
>![img](https://api2.mubu.com/v3/document_image/25165450_ab59dae6-15f5-4e79-dae4-65aadf9bd626.png)

  - `属性伤害类型` 和 `Debuff`
>![img](https://api2.mubu.com/v3/document_image/25165450_0145f8ce-70b5-4383-8646-e1367dd51560.png)

------

##### 可以通过 `属性伤害` 拿到 `对应的抗性` 再拿到 `对应捕获属性抗性的Def`


------

#### 再通过 `ExecutionParams.AttemptCalculateCapturedAttributeMagnitude` 拿到对应的属性值


------

##### 别忘了 `夹值` !


------

### Debuff概率，计算公式如下：

  - `应用Debuff概率 = Debuff概率参数 * （100 - 目标对应属性抗性）/ 100`

  - 这里就使用固定值了，也可以使用曲线

  - 根据上面的公式，现在每一点抗性都会使 应用Debuff的概率降低1%
>![img](https://api2.mubu.com/v3/document_image/25165450_a097964d-28ef-4066-ef20-aeeb06d93b2c.png)

- 现在需要随机，判定 `是否应用Debuff`


------

### 现在的处理步骤已经很多了，应该抽象一个函数

  - 命名为，`DetermineDebuff`
>![img](https://api2.mubu.com/v3/document_image/25165450_ca0f75b3-288f-4438-9bd0-e6f6336f7cc6.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_112aa5eb-a071-432c-ebe0-8d70ec9b5cb3.png)

------

#### 接下来，断点测试，看逻辑的参数是否正常
>![img](https://api2.mubu.com/v3/document_image/25165450_97e21a8a-3270-47bf-9b17-e8ed1fd831eb.png)

------

### 运行测试，向敌人发射火球，提前触发断点
>![img](https://api2.mubu.com/v3/document_image/25165450_738de11c-60b2-45b8-cfd7-b99f92c3f48f.png)

- 也就是说，我们从这个懒单例中的静态函数获取的 `TMap数组` 还没有初始化添加元素完成，就触发了下面的调用，导致 `Num ==1` 

- 如果想正常使用，可以不在懒单例的结构体构造内赋值，而是在函数内创建 `成员变量TMap` ，直接使用 `成员变量` (反正使用的也是一个`静态表` )
>![img](https://api2.mubu.com/v3/document_image/25165450_0824036a-431a-4a54-f5b9-3c150f8d7dc0.png)

------

### 在函数 `Execute_Implementation` 中创建成员变量TMap，保存静态表（将懒单例中构造中的添加元素挪到这里实现）
>![img](https://api2.mubu.com/v3/document_image/25165450_4956a706-1dff-44e5-88e1-c72dcba77a85.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_aea03509-2205-4e8c-bb3a-35cf1629a8e8.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_dbee2679-fd12-4ac5-fb36-e9c00a60bc6e.png)

------

#### 但是所有引用到 `对应捕获属性抗性的Def` 的地方都需要修改
>![img](https://api2.mubu.com/v3/document_image/25165450_ec3ffae5-8c33-4202-8ebd-7af488fc4fcc.png)

------

#### 函数 `DetermineDebuff` 中，也需要添加形参，需要这个TMap！
>![img](https://api2.mubu.com/v3/document_image/25165450_d7217998-b25b-4e95-bfec-32cece881c2c.png)

------

### 编译引擎后


------

### 现在有一个问题，我们之前没有为敌人 `次要属性GE` 添加  `4种属性的抗性`
>![img](https://api2.mubu.com/v3/document_image/25165450_b8c812ef-0b11-4e47-95fb-2e4603d9a7cb.png)

------

#### 先使用固定值20测试一下
>![img](https://api2.mubu.com/v3/document_image/25165450_08bb3a64-a82a-4e1b-ceaf-ba17e046c5b8.png)

------

### 继续测试断点结果是否正常
>![img](https://api2.mubu.com/v3/document_image/25165450_67921531-016e-43d8-ee1e-fe3f4a06c264.png)
>![img](https://api2.mubu.com/v3/document_image/25165450_c905f75e-3730-4fcf-8605-7713a167742c.png)

- 这回应该是正常的


------

### 参考Aura的 `次要属性GE` 来配置敌人的 `次要属性GE` 
>![img](https://api2.mubu.com/v3/document_image/25165450_d6d4ed3d-8390-4e17-d701-58ce0fe01bfe.png)

------

### 我们将在下一节，处理应用Debuff 需要发生的一系列逻辑
>![img](https://api2.mubu.com/v3/document_image/25165450_b194633d-f4d9-4e50-deda-8051baeb9de6.png)
___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
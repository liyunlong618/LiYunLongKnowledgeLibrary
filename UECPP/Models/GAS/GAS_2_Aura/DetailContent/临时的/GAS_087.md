<details>
<summary>过程截图</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 087在敌人攻击时，将目标地点半径内的Actors加入数组

___________________________________________________________________________________________

## 处理关键点

1. 111111111111111111111111111111

2. 222222222222222222222222222

3. 33333333333333333333333333

4. 4444444444444444444444444444

5. 555555555555555555555555555555

6. 666666666666666666666666666

7. 77777777777777777777777777777777

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[5. Get Live Players Within Radius_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=179&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 下面我们需要在敌人攻击时，以目标地点为半径，获取Actors数组

> 这个比较常用，比如可以批量的应用某种GE，这个涉及到查询相关的知识
>
> - 需要忽略一部分 Actor，比如忽略自身；或者敌人使用时，忽略同一阵营时；或者忽略已经死了的 Pawn

### 打算写到蓝图函数库里，方便调用获取

## 先处理死亡

### 现在接口中创建查询死亡和返回自身的函数

> ![img](https://api2.mubu.com/v3/document_image/25165450_f0406fdd-c1b2-4713-f213-7ce2a9decd3b.png)

------

### 角色标记没有死亡的变量，创建一个bool

> ![img](https://api2.mubu.com/v3/document_image/25165450_97ff1be8-554c-4ee5-815e-a58d8368955f.png)

------

### 角色基类中重写 ，接口函数打好备注

> ![img](https://api2.mubu.com/v3/document_image/25165450_4a3cb197-0833-4bf8-ecc3-b9001c9be425.png)![img](https://api2.mubu.com/v3/document_image/25165450_18554e80-aa9e-4c03-ca42-7f672745877a.png)

------

### 死亡变量无需复制

> ![img](https://api2.mubu.com/v3/document_image/25165450_23cf1cb2-963e-4620-8e22-1e8fb4693ed2.png)

------

### 蓝图函数库中创建要用的函数

> ![img](https://api2.mubu.com/v3/document_image/25165450_8c02a662-d032-4d85-90c6-98efd966c519.png)![img](https://api2.mubu.com/v3/document_image/25165450_0b855771-6f50-4a98-cd0e-ae928f1c78b7.png)

------

<details>
<summary>实现需要参考引擎的函数 ApplyRadialDamageWithFalloff </summary>


>需要参考的函数： ApplyRadialDamageWithFalloff
>
>![img](https://api2.mubu.com/v3/document_image/25165450_4d243ea4-6fa6-4dfc-eebd-9c0e0167610f.png)
>
>![img](https://api2.mubu.com/v3/document_image/25165450_c3bd23aa-7672-47ac-9831-5a7e77261e88.png)
>
>参数解释
>
>- 结构体：FCollisionQueryParams
>  - 结构体添加忽略的Actors数组
>
>- 创建了一个TArray<FOverlapResult> Overlaps 保存重叠结果
>
>- 获取世界上下文，如果没有会报错![img](https://api2.mubu.com/v3/document_image/25165450_10029f48-0ac9-4d54-a759-d0c7e2172aea.png)
>
>- 然后使用UWorld调用了World->OverlapMultiByObjectType
>
>- Origin 球形的原点
>
>- 球体旋转
>
>- 碰撞对象查询：动态![img](https://api2.mubu.com/v3/document_image/25165450_93e41094-ebd8-4345-8f36-d0d9158624bf.png)
>
>- 创建球体碰撞，需要传入半径![img](https://api2.mubu.com/v3/document_image/25165450_4a1d258d-2330-4a72-f249-42631a45c979.png)
>
>- 最后 遍历 重叠的结果数组，通过 Overlap.GetActor() 拿到碰撞检测到的Actor![img](https://api2.mubu.com/v3/document_image/25165450_18fc530f-f9a7-4330-8cf1-788a312d7d6e.png)
>- 使用函数，检查目标对象是否实现了接口![img](https://api2.mubu.com/v3/document_image/25165450_2442c182-a4f5-4daa-8cb4-6dc669efaf99.png)

------

</details>

------

### 重叠检测步骤

> 1.创建 添加忽略 Actors 用 结构体：FCollisionQueryParams，
>
> 2.创建保存检测重叠结果 TArray<FOverlapResult> Overlaps 
>
> 3.获取 UWorld 调用了 World->OverlapMultiByObjectType
>
> 4.遍历重叠检测结果，如果符合要求就存入数组
>
> 函数实现![img](https://api2.mubu.com/v3/document_image/25165450_e79ee6d3-1528-459b-dbb5-195ba79e1917.png)

------

### 蓝图中调用

> ![img](https://api2.mubu.com/v3/document_image/25165450_fe2eb92d-8815-4f24-e97c-27454593b428.png)![img](https://api2.mubu.com/v3/document_image/25165450_1d13492a-64a9-4734-ce19-37d0d27503e2.png)

------

### 此时站在火堆旁边，崩溃了

> ### 所以静态函数不允许我们检查任何未实现该接口的调用，就是下面的函数(需要问chatgpt)![img](https://api2.mubu.com/v3/document_image/25165450_a626a068-6431-4fce-9c2d-b926d94c2cb9.png)
>
> ### 此时有两种处理方案：
>
> - #### 一种是使用 cast 或者 if 
>
> - #### 因为 if 判断(如果有两个条件)是先判断前面的条件后判断后面的条件，如果前面的条件为 false ，则不执行后面的条件
>
>   所以可以先使用 `Implements` 判断，因为这个如果是空的会返回 `false` ，就 `不会执行到第二个条件` 的检查 `调用`
>
>   - 比如这样处理![img](https://api2.mubu.com/v3/document_image/25165450_b536570d-8c1f-4182-d5d4-6e435b787a12.png)

------

### 此时可以站在敌人旁边进行测试gif

> - 不崩溃了OK
>
>   ![image-20240826094138317](C:\Users\ZGF\AppData\Roaming\Typora\typora-user-images\image-20240826094138317.png)


___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________
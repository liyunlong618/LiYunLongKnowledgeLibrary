<details>
<summary>创建表格</summary>

>

------

</details>




+ `头文件`中：
```cpp
这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码这里是头文件代码
```

+ `源文件`中：
```cpp
这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码这里是源文件代码
```

[Mermaid格式参考](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/blob/main/Mermaid%E6%A0%BC%E5%BC%8F%E5%8F%82%E8%80%83.md)

[预览](https://github.com/liyunlong618/LiYunLongKnowledgeLibrary/tree/main/UECPP/Models/GAS/GAS_2_Aura)



___________________________________________________________________________________________
###### [Go主菜单](../MainMenu.md)
___________________________________________________________________________________________

# GAS 068 自建FGameplayEffectContext(2);重写 网络序列化函数 NetSerialize

___________________________________________________________________________________________

## 处理关键点

1. 重写 网络序列化函数 `NetSerialize`，使用 `uint32` 无符号整数来 重新记录序列化信息

2. 222222222222222222222222222

3. 33333333333333333333333333

4. 4444444444444444444444444444

5. 555555555555555555555555555555

6. 666666666666666666666666666

7. 77777777777777777777777777777777

___________________________________________________________________________________________

# 目录


[TOC]


___________________________________________________________________________________________

<details>
<summary>视频链接</summary>

[4. Implementing Net Serialize_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=150&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

[5. Struct Ops Type Traits_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1JD421E7yC?p=151&vd_source=9e1e64122d802b4f7ab37bd325a89e6c)

------

</details>

___________________________________________________________________________________________

### Mermaid整体思路梳理

Mermaid

___________________________________________________________________________________________

### 小测试1

- 你将为我们的自定义 `FGameplayEffectContext` 实现网络序列化
- 现在，制作一个 `uint32` ，命名为 `RepBits`
- 加载时为每个变量翻转其中的位。
- 现在，请确保在Repbits上调用 `SerializeBits`
- 然后检查每个位并存档或取消存档
- 根据每个变量是否已经翻转的位
- 现在，请查看Net Serialize的实现方式

> #### 看看你能否处理这个

![](./GAS_068/1.PNG)

<details>
<summary>自己尝试一下</summary>


>## 头文件在上一节已经写完了，这一节无改动
>
>## 源文件中需要：
>
>1. #### 保存时，增加自己的bool所占的bit位
>
>   ```CPP
>   /*
>    * 在这里增加了自己的类型
>    */
>   if (bIsBlockedHit)
>   {
>       RepBits |= 1 << 7;
>   }
>   if (bIsCriticalHit)
>   {
>       RepBits |= 1 << 8;
>   }
>   ```
>
>2. #### 读取时，增加自己的bool所占的bit位
>
>   ```CPP
>   /*
>    * 在这里增加了自己的类型
>    */
>   if (RepBits & (1 << 7))
>   {
>       Ar << bIsBlockedHit;
>   }
>   if (RepBits & (1 << 8))
>   {
>       Ar << bIsCriticalHit;
>   }
>   ```
>
>3. #### 需要设置 **`所占bit位的总长度`**
>
>   ```CPP
>   //在这里 需要将原来的长度从 7 修改成 9 (因为自己增加了两位)
>   Ar.SerializeBits(&RepBits, 9);
>   ```
>
>
>
>- `AuraAbilityTypes.h` 中
>
>```CPP
>// Copyright belongs to Li Yunlong.
>
>#pragma once
>
>#include "GameplayEffectTypes.h"
>#include "AuraAbilityTypes.generated.h"
>
>USTRUCT(BlueprintType)
>struct FAuraGameplayEffectContext : public FGameplayEffectContext
>{
>    GENERATED_BODY()
>
>public:
>
>    //重写父类虚函数 脚本化 结构体
>    virtual UScriptStruct* GetScriptStruct() const override
>    {
>       return FGameplayEffectContext::StaticStruct();
>    }
>
>    //重写父类虚函数 网络序列化
>    virtual bool NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess) override;
>
>    /*
>     *Get
>     */
>    FORCEINLINE bool IsCriticalHit() const { return bIsCriticalHit; }
>    FORCEINLINE bool IsBlockedHit() const { return bIsBlockedHit; }
>
>    /*
>     * Set
>     */
>    FORCEINLINE void SetIsCriticalHit(const bool bInIsCriticalHit) { bIsCriticalHit = bInIsCriticalHit; }
>    FORCEINLINE void SetIsBlockedHit(const bool bInIsBlockedHit) { bIsBlockedHit = bInIsBlockedHit; }
>
>protected:
>
>    UPROPERTY()
>    bool bIsBlockedHit = false;/*是否被格挡*/
>    UPROPERTY()
>    bool bIsCriticalHit = false;/*是否暴击*/
>};
>```
>
>- `AuraAbilityTypes.cpp` 中
>
>```CPP
>#include "AuraAbilityTypes.h"
>
>bool FAuraGameplayEffectContext::NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess)
>{
>    //原来是创建了 uint8 8bit的无符号整数 现在需要创建一个 uint32 32bit的无符号整数 携带更多信息
>    uint32 RepBits = 0;
>
>    if (Ar.IsSaving())
>    {
>       if (bReplicateInstigator && Instigator.IsValid())
>       {
>          RepBits |= 1 << 0;
>       }
>       if (bReplicateEffectCauser && EffectCauser.IsValid() )
>       {
>          RepBits |= 1 << 1;
>       }
>       if (AbilityCDO.IsValid())
>       {
>          RepBits |= 1 << 2;
>       }
>       if (bReplicateSourceObject && SourceObject.IsValid())
>       {
>          RepBits |= 1 << 3;
>       }
>       if (Actors.Num() > 0)
>       {
>          RepBits |= 1 << 4;
>       }
>       if (HitResult.IsValid())
>       {
>          RepBits |= 1 << 5;
>       }
>       if (bHasWorldOrigin)
>       {
>          RepBits |= 1 << 6;
>       }
>       /*
>        * 在这里增加了自己的类型
>        */
>       if (bIsBlockedHit)
>       {
>          RepBits |= 1 << 7;
>       }
>       if (bIsCriticalHit)
>       {
>          RepBits |= 1 << 8;
>       }
>    }
>
>    //在这里 需要将原来的长度从 7 修改成 9 (因为自己增加了两位)
>    Ar.SerializeBits(&RepBits, 9);
>
>    if (RepBits & (1 << 0))
>    {
>       Ar << Instigator;
>    }
>    if (RepBits & (1 << 1))
>    {
>       Ar << EffectCauser;
>    }
>    if (RepBits & (1 << 2))
>    {
>       Ar << AbilityCDO;
>    }
>    if (RepBits & (1 << 3))
>    {
>       Ar << SourceObject;
>    }
>    if (RepBits & (1 << 4))
>    {
>       SafeNetSerializeTArray_Default<31>(Ar, Actors);
>    }
>    if (RepBits & (1 << 5))
>    {
>       if (Ar.IsLoading())
>       {
>          if (!HitResult.IsValid())
>          {
>             HitResult = TSharedPtr<FHitResult>(new FHitResult());
>          }
>       }
>       HitResult->NetSerialize(Ar, Map, bOutSuccess);
>    }
>    if (RepBits & (1 << 6))
>    {
>       Ar << WorldOrigin;
>       bHasWorldOrigin = true;
>    }
>    else
>    {
>       bHasWorldOrigin = false;
>    }
>
>    /*
>     * 在这里增加了自己的类型
>     */
>    if (RepBits & (1 << 7))
>    {
>       Ar << bIsBlockedHit;
>    }
>    if (RepBits & (1 << 8))
>    {
>       Ar << bIsCriticalHit;
>    }
>
>    if (Ar.IsLoading())
>    {
>       AddInstigator(Instigator.Get(), EffectCauser.Get()); // Just to initialize InstigatorAbilitySystemComponent
>    }  
>
>    bOutSuccess = true;
>    return true;
>}
>```

------

</details>










___________________________________________________________________________________________

[返回最上面](#Go主菜单)

___________________________________________________________________________________________